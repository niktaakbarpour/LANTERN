{
    "oai_response": {
        "choices": [
            {
                "message": {
                    "role": "assistant",
                    "content": "```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace ReadWriteTemplate\n{\n    public static class Solver\n    {\n        private static void SolveCase()\n        {\n            const long MOD = 998244353;\n\n            int n = ReadInt();\n            int k = ReadInt();\n            long l = ReadInt();\n\n            long[][] dp = new long[n + 1][];\n            dp[0] = new long[k + 1];\n            dp[0][0] = 1;\n            for (int s = 1; s <= n; s++)\n            {\n                dp[s] = new long[n + 1];\n                dp[s][0] = s * (s - 1) / 2 % MOD;\n                for (int c = 1; c <= n && c <= s; c++)\n                {\n                    dp[s][c] = (c * dp[s - 1][c - 1] % MOD + (s - c) * dp[s - 1][c] % MOD) % MOD;\n                }\n            }\n\n            long ans = 0;\n            for (int c = k; c <= n; c++)\n            {\n                ans = (ans + dp[n][c]) % MOD;\n            }\n            ans = ans * l % MOD;\n\n            Writer.WriteLine(ans);\n        }\n\n        public static void Main()\n        {\n            Solve();\n        }\n\n        public static void Solve()\n        {\n            SolveCase();\n        }\n\n        #region Read/Write\n\n        private static TextReader Reader = Console.In;\n\n        private static TextWriter Writer = Console.Out;\n\n        private static Queue<string> CurrentLineTokens = new Queue<string>();\n\n        private static string[] ReadAndSplitLine()\n        {\n            return Reader.ReadLine().Split(new[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public static string ReadToken()\n        {\n            while (CurrentLineTokens.Count == 0)\n                CurrentLineTokens = new Queue<string>(ReadAndSplitLine());\n            return CurrentLineTokens.Dequeue();\n        }\n\n        public static string ReadLine()\n        {\n            return Reader.ReadLine();\n        }\n\n        public static int ReadInt()\n        {\n            return int.Parse(ReadToken());\n        }\n\n        public static long ReadLong()\n        {\n            return long.Parse(ReadToken());\n        }\n\n        public static double ReadDouble()\n        {\n            return double.Parse(ReadToken(), CultureInfo.InvariantCulture);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            return ReadAndSplitLine().Select(int.Parse).ToArray();\n        }\n\n        public static long[] ReadLongArray()\n        {\n            return ReadAndSplitLine().Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray();\n        }\n\n        public static int[][] ReadIntMatrix(int numberOfRows)\n        {\n            int[][] matrix = new int[numberOfRows][];\n            for (int i = 0; i < numberOfRows; i++)\n                matrix[i] = ReadIntArray();\n            return matrix;\n        }\n\n        public static string[] ReadLines(int quantity)\n        {\n            string[] lines = new string[quantity];\n            for (int i = 0; i < quantity; i++)\n                lines[i] = Reader.ReadLine().Trim();\n            return lines;\n        }\n\n        public static void WriteArray<T>(IEnumerable<T> array)\n        {\n            Writer.WriteLine(string.Join(\" \", array));\n        }\n\n        #endregion\n    }\n}\n```"
                }
            }
        ],
        "prompt": [
            "Fix a buggy program written in C# language to solve the following programming problem:\nDescription: Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows.You are given a segment with length $$$l$$$. We randomly choose $$$n$$$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $$$n$$$, and another integer $$$k$$$. The $$$2n$$$ endpoints of the chosen segments split the segment into $$$(2n+1)$$$ intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $$$k$$$ segments of the $$$n$$$ random segments.You should find the answer modulo $$$998244353$$$.\nInput Specification: First line contains three space-separated positive integers $$$n$$$, $$$k$$$ and $$$l$$$ ($$$1\\leq k \\leq n \\leq 2000$$$, $$$1\\leq l\\leq 10^9$$$).\nOutput Specification: Output one integer\u00a0\u2014 the expected total length of all the intervals covered by at least $$$k$$$ segments of the $$$n$$$ random segments modulo $$$998244353$$$. Formally, let $$$M = 998244353$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.\n\nSample Input:\n1 1 1\nSample Output:\n332748118\n\nSample Input:\n6 2 1\nSample Output:\n760234711\n\nSample Input:\n7 5 3\nSample Output:\n223383352\n\nSample Input:\n97 31 9984524\nSample Output:\n267137618\n\nNotes: NoteIn the first example, the expected total length is $$$\\int_0^1 \\int_0^1 |x-y| \\,\\mathrm{d}x\\,\\mathrm{d}y = {1\\over 3}$$$, and $$$3^{-1}$$$ modulo $$$998244353$$$ is $$$332748118$$$.\nTake input from standard input and output to standard output\n\nHere is the code with a bug of MEMORY_LIMIT_EXCEEDED:\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\nnamespace ReadWriteTemplate\n{\n    public static class Solver\n    {\n        private static void SolveCase()\n        {\n            const long MOD = 998244353;\n\n            int n = ReadInt();\n            int k = ReadInt();\n            long l = ReadInt();\n\n            int N = 2 * n + 2;\n            long[,,] a = new long[N, N, 2];\n            long[,,] b = new long[N, N, 2];\n            a[0, 0, 0] = 1;\n            b[0, 0, 0] = 1;\n\n            for (int i = 0; i < 2 * n + 1; i++)\n            {\n                for (int j = 0; j <= i; j++)\n                {\n                    for (int e = 0; e < 2; e++)\n                    {\n                        if (e == 0)\n                        {\n                            if (j >= k)\n                            {\n                                a[i + 1, j, 1] += a[i, j, e];\n                                Fix(ref a[i + 1, j, 1], MOD);\n                            }\n                            b[i + 1, j, 1] += b[i, j, e];\n                            Fix(ref b[i + 1, j, 1], MOD);\n                        }\n                        if (j > 0)\n                        {\n                            a[i + 1, j - 1, e] = (a[i + 1, j - 1, e] + j * a[i, j, e]) % MOD;\n                            b[i + 1, j - 1, e] = (b[i + 1, j - 1, e] + j * b[i, j, e]) % MOD;\n                        }\n                        if (i + j - e <= 2 * n - 2)\n                        {\n                            a[i + 1, j + 1, e] += a[i, j, e];\n                            Fix(ref a[i + 1, j + 1, e], MOD);\n                            b[i + 1, j + 1, e] += b[i, j, e];\n                            Fix(ref b[i + 1, j + 1, e], MOD);\n                        }\n                    }\n                }\n            }\n\n            long ans = a[2 * n + 1, 0, 1] * Inv(b[2 * n + 1, 0, 1], MOD) % MOD;\n            ans = ans * l % MOD;\n\n            Writer.WriteLine(ans);\n        }\n\n        public static void Fix(ref long x, long mod)\n        {\n            if (x >= mod)\n            {\n                x -= mod;\n            }\n        }\n\n        public static long Inv(long a, long mod)\n        {\n            return BinPower(a, mod - 2, mod);\n        }\n\n        public static long BinPower(long a, long n, long mod)\n        {\n            long result = 1;\n\n            while (n > 0)\n            {\n                if ((n & 1) != 0)\n                {\n                    result = (result * a) % mod;\n                }\n\n                a = (a * a) % mod;\n                n >>= 1;\n            }\n\n            return result;\n        }\n\n        public static void Solve()\n        {\n#if DEBUG\n            var sw = Stopwatch.StartNew();\n#endif\n\n            SolveCase();\n\n            /*int T = ReadInt();\n            for (int i = 0; i < T; i++)\n            {\n                Writer.Write(\"Case #{0}: \", i + 1);\n                SolveCase();\n            }*/\n\n#if DEBUG\n            sw.Stop();\n            Console.WriteLine($\"{sw.ElapsedMilliseconds} ms\");\n#endif\n        }\n\n        public static void Main()\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n#if DEBUG\n            // Reader = Console.In; Writer = Console.Out;\n            Reader = File.OpenText(\"input.txt\"); Writer = File.CreateText(\"output.txt\");\n#else\n            Reader = Console.In; Writer = Console.Out;\n#endif\n\n            // Solve();\n            Thread thread = new Thread(Solve, 64 * 1024 * 1024);\n            thread.CurrentCulture = CultureInfo.InvariantCulture;\n            thread.Start();\n            thread.Join();\n\n            Reader.Close();\n            Writer.Close();\n        }\n\n        public static IOrderedEnumerable<TSource> OrderByWithShuffle<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)\n        {\n            return source.Shuffle().OrderBy(keySelector);\n        }\n\n        public static T[] Shuffle<T>(this IEnumerable<T> source)\n        {\n            T[] result = source.ToArray();\n            Shuffle(result);\n            return result;\n        }\n\n        private static void Shuffle<T>(IList<T> array)\n        {\n            Random rnd = new Random();\n            for (int i = array.Count - 1; i >= 1; i--)\n            {\n                int k = rnd.Next(i + 1);\n                T tmp = array[k];\n                array[k] = array[i];\n                array[i] = tmp;\n            }\n        }\n\n        #region Read/Write\n\n        private static TextReader Reader;\n\n        private static TextWriter Writer;\n\n        private static Queue<string> CurrentLineTokens = new Queue<string>();\n\n        private static string[] ReadAndSplitLine()\n        {\n            return Reader.ReadLine().Split(new[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public static string ReadToken()\n        {\n            while (CurrentLineTokens.Count == 0)\n                CurrentLineTokens = new Queue<string>(ReadAndSplitLine());\n            return CurrentLineTokens.Dequeue();\n        }\n\n        public static string ReadLine()\n        {\n            return Reader.ReadLine();\n        }\n\n        public static int ReadInt()\n        {\n            return int.Parse(ReadToken());\n        }\n\n        public static long ReadLong()\n        {\n            return long.Parse(ReadToken());\n        }\n\n        public static double ReadDouble()\n        {\n            return double.Parse(ReadToken(), CultureInfo.InvariantCulture);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            return ReadAndSplitLine().Select(int.Parse).ToArray();\n        }\n\n        public static long[] ReadLongArray()\n        {\n            return ReadAndSplitLine().Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray();\n        }\n\n        public static int[][] ReadIntMatrix(int numberOfRows)\n        {\n            int[][] matrix = new int[numberOfRows][];\n            for (int i = 0; i < numberOfRows; i++)\n                matrix[i] = ReadIntArray();\n            return matrix;\n        }\n\n        public static string[] ReadLines(int quantity)\n        {\n            string[] lines = new string[quantity];\n            for (int i = 0; i < quantity; i++)\n                lines[i] = Reader.ReadLine().Trim();\n            return lines;\n        }\n\n        public static void WriteArray<T>(IEnumerable<T> array)\n        {\n            Writer.WriteLine(string.Join(\" \", array));\n        }\n\n        #endregion\n    }\n}\n\n\nProvide the fixed C# code without any description or extra tokens.\n\nFixed source code:",
            ""
        ]
    },
    "source_data": {
        "delete_cnt": 15,
        "fix_code_uid": "",
        "difficulty": 2600,
        "replace_cnt": 22,
        "fix_ops_cnt": 45,
        "prob_desc_output_spec": "Output one integer\u00a0\u2014 the expected total length of all the intervals covered by at least $$$k$$$ segments of the $$$n$$$ random segments modulo $$$998244353$$$. Formally, let $$$M = 998244353$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.",
        "apr_id": "54af8479f24beaf10fb1897b0a6ed0c8",
        "bug_source_code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\nnamespace ReadWriteTemplate\n{\n    public static class Solver\n    {\n        private static void SolveCase()\n        {\n            const long MOD = 998244353;\n\n            int n = ReadInt();\n            int k = ReadInt();\n            long l = ReadInt();\n\n            int N = 2 * n + 2;\n            long[,,] a = new long[N, N, 2];\n            long[,,] b = new long[N, N, 2];\n            a[0, 0, 0] = 1;\n            b[0, 0, 0] = 1;\n\n            for (int i = 0; i < 2 * n + 1; i++)\n            {\n                for (int j = 0; j <= i; j++)\n                {\n                    for (int e = 0; e < 2; e++)\n                    {\n                        if (e == 0)\n                        {\n                            if (j >= k)\n                            {\n                                a[i + 1, j, 1] += a[i, j, e];\n                                Fix(ref a[i + 1, j, 1], MOD);\n                            }\n                            b[i + 1, j, 1] += b[i, j, e];\n                            Fix(ref b[i + 1, j, 1], MOD);\n                        }\n                        if (j > 0)\n                        {\n                            a[i + 1, j - 1, e] = (a[i + 1, j - 1, e] + j * a[i, j, e]) % MOD;\n                            b[i + 1, j - 1, e] = (b[i + 1, j - 1, e] + j * b[i, j, e]) % MOD;\n                        }\n                        if (i + j - e <= 2 * n - 2)\n                        {\n                            a[i + 1, j + 1, e] += a[i, j, e];\n                            Fix(ref a[i + 1, j + 1, e], MOD);\n                            b[i + 1, j + 1, e] += b[i, j, e];\n                            Fix(ref b[i + 1, j + 1, e], MOD);\n                        }\n                    }\n                }\n            }\n\n            long ans = a[2 * n + 1, 0, 1] * Inv(b[2 * n + 1, 0, 1], MOD) % MOD;\n            ans = ans * l % MOD;\n\n            Writer.WriteLine(ans);\n        }\n\n        public static void Fix(ref long x, long mod)\n        {\n            if (x >= mod)\n            {\n                x -= mod;\n            }\n        }\n\n        public static long Inv(long a, long mod)\n        {\n            return BinPower(a, mod - 2, mod);\n        }\n\n        public static long BinPower(long a, long n, long mod)\n        {\n            long result = 1;\n\n            while (n > 0)\n            {\n                if ((n & 1) != 0)\n                {\n                    result = (result * a) % mod;\n                }\n\n                a = (a * a) % mod;\n                n >>= 1;\n            }\n\n            return result;\n        }\n\n        public static void Solve()\n        {\n#if DEBUG\n            var sw = Stopwatch.StartNew();\n#endif\n\n            SolveCase();\n\n            /*int T = ReadInt();\n            for (int i = 0; i < T; i++)\n            {\n                Writer.Write(\"Case #{0}: \", i + 1);\n                SolveCase();\n            }*/\n\n#if DEBUG\n            sw.Stop();\n            Console.WriteLine($\"{sw.ElapsedMilliseconds} ms\");\n#endif\n        }\n\n        public static void Main()\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n#if DEBUG\n            // Reader = Console.In; Writer = Console.Out;\n            Reader = File.OpenText(\"input.txt\"); Writer = File.CreateText(\"output.txt\");\n#else\n            Reader = Console.In; Writer = Console.Out;\n#endif\n\n            // Solve();\n            Thread thread = new Thread(Solve, 64 * 1024 * 1024);\n            thread.CurrentCulture = CultureInfo.InvariantCulture;\n            thread.Start();\n            thread.Join();\n\n            Reader.Close();\n            Writer.Close();\n        }\n\n        public static IOrderedEnumerable<TSource> OrderByWithShuffle<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)\n        {\n            return source.Shuffle().OrderBy(keySelector);\n        }\n\n        public static T[] Shuffle<T>(this IEnumerable<T> source)\n        {\n            T[] result = source.ToArray();\n            Shuffle(result);\n            return result;\n        }\n\n        private static void Shuffle<T>(IList<T> array)\n        {\n            Random rnd = new Random();\n            for (int i = array.Count - 1; i >= 1; i--)\n            {\n                int k = rnd.Next(i + 1);\n                T tmp = array[k];\n                array[k] = array[i];\n                array[i] = tmp;\n            }\n        }\n\n        #region Read/Write\n\n        private static TextReader Reader;\n\n        private static TextWriter Writer;\n\n        private static Queue<string> CurrentLineTokens = new Queue<string>();\n\n        private static string[] ReadAndSplitLine()\n        {\n            return Reader.ReadLine().Split(new[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public static string ReadToken()\n        {\n            while (CurrentLineTokens.Count == 0)\n                CurrentLineTokens = new Queue<string>(ReadAndSplitLine());\n            return CurrentLineTokens.Dequeue();\n        }\n\n        public static string ReadLine()\n        {\n            return Reader.ReadLine();\n        }\n\n        public static int ReadInt()\n        {\n            return int.Parse(ReadToken());\n        }\n\n        public static long ReadLong()\n        {\n            return long.Parse(ReadToken());\n        }\n\n        public static double ReadDouble()\n        {\n            return double.Parse(ReadToken(), CultureInfo.InvariantCulture);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            return ReadAndSplitLine().Select(int.Parse).ToArray();\n        }\n\n        public static long[] ReadLongArray()\n        {\n            return ReadAndSplitLine().Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray();\n        }\n\n        public static int[][] ReadIntMatrix(int numberOfRows)\n        {\n            int[][] matrix = new int[numberOfRows][];\n            for (int i = 0; i < numberOfRows; i++)\n                matrix[i] = ReadIntArray();\n            return matrix;\n        }\n\n        public static string[] ReadLines(int quantity)\n        {\n            string[] lines = new string[quantity];\n            for (int i = 0; i < quantity; i++)\n                lines[i] = Reader.ReadLine().Trim();\n            return lines;\n        }\n\n        public static void WriteArray<T>(IEnumerable<T> array)\n        {\n            Writer.WriteLine(string.Join(\" \", array));\n        }\n\n        #endregion\n    }\n}\n",
        "prob_desc_input_spec": "First line contains three space-separated positive integers $$$n$$$, $$$k$$$ and $$$l$$$ ($$$1\\leq k \\leq n \\leq 2000$$$, $$$1\\leq l\\leq 10^9$$$).",
        "src_uid": "c9e79e83928d5d034123ebc3b2f5e064",
        "bug_code_uid": "971e055bdbb04028d21c44d373b7fc7a",
        "equal_cnt": 46,
        "prob_desc_time_limit": "1 second",
        "similarity_score": 0.9464351534843445,
        "bug_exec_outcome": "MEMORY_LIMIT_EXCEEDED",
        "lang_cluster": "C#",
        "potential_dominant_fix_op": "replace",
        "prob_desc_sample_inputs": [
            "1 1 1",
            "6 2 1",
            "7 5 3",
            "97 31 9984524"
        ],
        "prob_desc_input_from": "standard input",
        "prob_desc_description": "Getting closer and closer to a mathematician, Serval becomes a university student on math major in Japari University. On the Calculus class, his teacher taught him how to calculate the expected length of a random subsegment of a given segment. Then he left a bonus problem as homework, with the award of a garage kit from IOI. The bonus is to extend this problem to the general case as follows.You are given a segment with length $$$l$$$. We randomly choose $$$n$$$ segments by choosing two points (maybe with non-integer coordinates) from the given segment equiprobably and the interval between the two points forms a segment. You are given the number of random segments $$$n$$$, and another integer $$$k$$$. The $$$2n$$$ endpoints of the chosen segments split the segment into $$$(2n+1)$$$ intervals. Your task is to calculate the expected total length of those intervals that are covered by at least $$$k$$$ segments of the $$$n$$$ random segments.You should find the answer modulo $$$998244353$$$.",
        "lang": "Mono C#",
        "fix_exec_outcome": "",
        "insert_cnt": 8,
        "fix_source_code": "",
        "prob_desc_notes": "NoteIn the first example, the expected total length is $$$\\int_0^1 \\int_0^1 |x-y| \\,\\mathrm{d}x\\,\\mathrm{d}y = {1\\over 3}$$$, and $$$3^{-1}$$$ modulo $$$998244353$$$ is $$$332748118$$$.",
        "file_name": "C#.jsonl",
        "tags": [
            "dp",
            "math",
            "combinatorics",
            "probabilities"
        ],
        "prob_desc_output_to": "standard output",
        "prob_desc_created_at": "1555164300",
        "prob_desc_memory_limit": "256 megabytes",
        "prob_desc_sample_outputs": [
            "332748118",
            "760234711",
            "223383352",
            "267137618"
        ],
        "hidden_unit_tests": "[{\"input\": \"1 1 1\\r\\n\", \"output\": [\"332748118\"]}, {\"input\": \"6 2 1\\r\\n\", \"output\": [\"760234711\"]}, {\"input\": \"7 5 3\\r\\n\", \"output\": [\"223383352\"]}, {\"input\": \"97 31 9984524\\r\\n\", \"output\": [\"267137618\"]}, {\"input\": \"2000 1 772197283\\r\\n\", \"output\": [\"905584809\"]}, {\"input\": \"2000 2 76039754\\r\\n\", \"output\": [\"855496918\"]}, {\"input\": \"2000 3 40337285\\r\\n\", \"output\": [\"782495326\"]}, {\"input\": \"2000 2000 773356966\\r\\n\", \"output\": [\"104351589\"]}, {\"input\": \"2000 1999 239479112\\r\\n\", \"output\": [\"620815507\"]}, {\"input\": \"2000 1998 334042678\\r\\n\", \"output\": [\"322694394\"]}, {\"input\": \"2000 976 671942688\\r\\n\", \"output\": [\"767696001\"]}, {\"input\": \"2000 1415 40371690\\r\\n\", \"output\": [\"171032298\"]}, {\"input\": \"2000 1000 1000000000\\r\\n\", \"output\": [\"491672258\"]}, {\"input\": \"1998 1001 998244353\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2000 4 136878315\\r\\n\", \"output\": [\"880870575\"]}, {\"input\": \"2000 5 558837462\\r\\n\", \"output\": [\"18859862\"]}, {\"input\": \"2000 1997 525997660\\r\\n\", \"output\": [\"843278067\"]}, {\"input\": \"2000 1996 45458693\\r\\n\", \"output\": [\"772786701\"]}, {\"input\": \"2000 1947 62604662\\r\\n\", \"output\": [\"540795249\"]}, {\"input\": \"2000 1728 63723796\\r\\n\", \"output\": [\"421421553\"]}, {\"input\": \"1961 206 931072038\\r\\n\", \"output\": [\"794464980\"]}, {\"input\": \"1948 978 501529426\\r\\n\", \"output\": [\"50139353\"]}, {\"input\": \"1878 1529 66841298\\r\\n\", \"output\": [\"880727658\"]}, {\"input\": \"1900 1 495084177\\r\\n\", \"output\": [\"338668438\"]}, {\"input\": \"1885 2 286102770\\r\\n\", \"output\": [\"443099162\"]}, {\"input\": \"1928 3 200575371\\r\\n\", \"output\": [\"291241927\"]}, {\"input\": \"1978 4 436588015\\r\\n\", \"output\": [\"282947523\"]}, {\"input\": \"1987 1987 191667504\\r\\n\", \"output\": [\"627381301\"]}, {\"input\": \"1821 1820 866603455\\r\\n\", \"output\": [\"318623064\"]}, {\"input\": \"1824 1822 151884700\\r\\n\", \"output\": [\"462069981\"]}, {\"input\": \"1486 1 170331068\\r\\n\", \"output\": [\"692176218\"]}, {\"input\": \"1424 1 217388653\\r\\n\", \"output\": [\"56808622\"]}, {\"input\": \"1703 1 803103605\\r\\n\", \"output\": [\"660333930\"]}, {\"input\": \"1555 1 700556118\\r\\n\", \"output\": [\"615656029\"]}, {\"input\": \"1224 1 71403225\\r\\n\", \"output\": [\"128242924\"]}, {\"input\": \"1492 1 599215694\\r\\n\", \"output\": [\"195441337\"]}, {\"input\": \"1281 1 415457117\\r\\n\", \"output\": [\"111407914\"]}, {\"input\": \"1664 1 517151944\\r\\n\", \"output\": [\"126430274\"]}, {\"input\": \"1771 1 555450393\\r\\n\", \"output\": [\"280416119\"]}, {\"input\": \"1045 1 375567139\\r\\n\", \"output\": [\"983012429\"]}, {\"input\": \"1025 1025 871316577\\r\\n\", \"output\": [\"266993477\"]}, {\"input\": \"1243 1243 296556443\\r\\n\", \"output\": [\"209836419\"]}, {\"input\": \"1240 1240 846679367\\r\\n\", \"output\": [\"744376915\"]}, {\"input\": \"1946 1946 432053608\\r\\n\", \"output\": [\"329055332\"]}, {\"input\": \"1806 1806 174417450\\r\\n\", \"output\": [\"287857698\"]}, {\"input\": \"1321 1321 774237640\\r\\n\", \"output\": [\"573916469\"]}, {\"input\": \"1205 1205 972407779\\r\\n\", \"output\": [\"970505824\"]}, {\"input\": \"1063 1063 497812546\\r\\n\", \"output\": [\"203394740\"]}, {\"input\": \"1443 1443 784034214\\r\\n\", \"output\": [\"489871338\"]}, {\"input\": \"1099 1099 548018740\\r\\n\", \"output\": [\"530449224\"]}, {\"input\": \"1334 667 998244356\\r\\n\", \"output\": [\"123570327\"]}, {\"input\": \"1621 810 998244355\\r\\n\", \"output\": [\"334476739\"]}, {\"input\": \"1253 626 998244353\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1217 608 998244355\\r\\n\", \"output\": [\"465345479\"]}, {\"input\": \"1966 983 998244357\\r\\n\", \"output\": [\"81898103\"]}, {\"input\": \"1471 735 998244354\\r\\n\", \"output\": [\"399941190\"]}, {\"input\": \"1496 748 998244357\\r\\n\", \"output\": [\"419593982\"]}, {\"input\": \"1307 653 998244355\\r\\n\", \"output\": [\"823060783\"]}, {\"input\": \"1706 853 998244357\\r\\n\", \"output\": [\"627644358\"]}, {\"input\": \"1025 512 998244357\\r\\n\", \"output\": [\"120622427\"]}]"
    }
}