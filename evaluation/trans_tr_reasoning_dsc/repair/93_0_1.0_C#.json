{
    "oai_response": {
        "choices": [
            {
                "message": {
                    "role": "assistant",
                    "content": "```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    private int N, X, Pos;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        N = sc.NextInt();\n        X = sc.NextInt();\n        Pos = sc.NextInt();\n\n        List<int> g = new List<int>();\n        List<int> l = new List<int>();\n        int left = 0;\n        int right = N;\n        while (left < right)\n        {\n            int middle = (left + right) / 2;\n            if (middle <= Pos)\n            {\n                l.Add(middle);\n                left = middle + 1;\n            }\n            else\n            {\n                g.Add(middle);\n                right = middle;\n            }\n        }\n\n        var c = new BinomialCoefficient(5000);\n        ModInt ans = c.RepeatedCombination(N - (l.Count + g.Count), X - 1);\n        Console.WriteLine(ans);\n    }\n\n    public static void Main(string[] args) => new Program().Solve();\n}\n\npublic struct ModInt\n{\n    public const long Mod = (int) 1e9 + 7;\n\n    public long num;\n\n    public ModInt(long n)\n    {\n        num = n % Mod;\n        if (num < 0) num += Mod;\n    }\n\n    public static ModInt operator +(ModInt l, ModInt r) => new ModInt((l.num + r.num) % Mod);\n\n    public static ModInt operator -(ModInt l, ModInt r) => new ModInt((l.num - r.num + Mod) % Mod);\n\n    public static ModInt operator *(ModInt l, ModInt r) => new ModInt(l.num * r.num % Mod);\n\n    public static implicit operator ModInt(long n) => new ModInt(n % Mod);\n\n    public static ModInt Pow(ModInt v, long k)\n    {\n        ModInt ret = 1;\n        while (k > 0)\n        {\n            if ((k & 1) == 1)\n                ret = ret * v;\n            v = v * v;\n            k >>= 1;\n        }\n        return ret;\n    }\n\n    public static ModInt Inverse(ModInt v) => Pow(v, Mod - 2);\n}\n\npublic class BinomialCoefficient\n{\n    private ModInt[] fact, ifact;\n\n    public BinomialCoefficient(int n)\n    {\n        fact = new ModInt[n + 1];\n        ifact = new ModInt[n + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= n; i++)\n            fact[i] = fact[i - 1] * i;\n        ifact[n] = ModInt.Inverse(fact[n]);\n        for (int i = n - 1; i >= 0; i--)\n            ifact[i] = ifact[i + 1] * (i + 1);\n    }\n\n    public ModInt this[int n, int k]\n    {\n        get\n        {\n            if (k < 0 || k > n) return 0;\n            return fact[n] * ifact[k] * ifact[n - k];\n        }\n    }\n\n    public ModInt RepeatedCombination(int n, int k)\n    {\n        if (k == 0) return 1;\n        return this[n + k - 1, k];\n    }\n}\n\nclass Scanner\n{\n    private string[] _line;\n    private int _index;\n    private const char Separator = ' ';\n\n    public Scanner()\n    {\n        _line = new string[0];\n        _index = 0;\n    }\n\n    public string Next()\n    {\n        if (_index >= _line.Length)\n        {\n            string s;\n            do\n            {\n                s = Console.ReadLine();\n            } while (s.Length == 0);\n\n            _line = s.Split(Separator);\n            _index = 0;: 7```"
                }
            }
        ],
        "prompt": [
            "Fix a buggy program written in C# language to solve the following programming problem:\nDescription: Andrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $$$x$$$ in an array. For an array $$$a$$$ indexed from zero, and an integer $$$x$$$ the pseudocode of the algorithm is as follows:  Note that the elements of the array are indexed from zero, and the division is done in integers (rounding down).Andrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $$$x$$$!Andrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $$$n$$$ such that the algorithm finds $$$x$$$ in them. A permutation of size $$$n$$$ is an array consisting of $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ in arbitrary order.Help Andrey and find the number of permutations of size $$$n$$$ which contain $$$x$$$ at position $$$pos$$$ and for which the given implementation of the binary search algorithm finds $$$x$$$ (returns true). As the result may be extremely large, print the remainder of its division by $$$10^9+7$$$.\nInput Specification: The only line of input contains integers $$$n$$$, $$$x$$$ and $$$pos$$$ ($$$1 \\le x \\le n \\le 1000$$$, $$$0 \\le pos \\le n - 1$$$) \u2014 the required length of the permutation, the number to search, and the required position of that number, respectively.\nOutput Specification: Print a single number\u00a0\u2014 the remainder of the division of the number of valid permutations by $$$10^9+7$$$.\n\nSample Input:\n4 1 2\nSample Output:\n6\n\nSample Input:\n123 42 24\nSample Output:\n824071958\n\nNotes: NoteAll possible permutations in the first test case: $$$(2, 3, 1, 4)$$$, $$$(2, 4, 1, 3)$$$, $$$(3, 2, 1, 4)$$$, $$$(3, 4, 1, 2)$$$, $$$(4, 2, 1, 3)$$$, $$$(4, 3, 1, 2)$$$.\nTake input from standard input and output to standard output\n\nHere is the code with a bug of RUNTIME_ERROR:\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing CompLib.Util;\nusing System.Threading;\nusing CompLib.Mathematics;\n\npublic class Program\n{\n    private int N, X, Pos;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        N = sc.NextInt();\n        X = sc.NextInt();\n        Pos = sc.NextInt();\n\n        List<int> g = new List<int>();\n        List<int> l = new List<int>();\n        int left = 0;\n        int right = N;\n        while (left < right)\n        {\n            int middle = (left + right) / 2;\n            if (middle <= Pos)\n            {\n                l.Add(middle);\n                left = middle + 1;\n            }\n            else\n            {\n                g.Add(middle);\n                right = middle;\n            }\n        }\n\n        // x\u672a\u6e80 len(l)-1\u500b\n        // x\u8d85\u904e len(g)\u500b\n\n        // \u306e\u3053\u308a\u3066\u304d\u3068\u3046\n\n        var c = new BinomialCoefficient(5000);\n        ModInt ans = c.fact[X - 1] * c.ifact[(X - 1) - (l.Count - 1)];\n        ans *= c.fact[N - X] * c.ifact[(N - X) - g.Count];\n        ans *= c.fact[N - (l.Count + g.Count)];\n        Console.WriteLine(ans);\n    }\n\n    public static void Main(string[] args) => new Program().Solve();\n    // public static void Main(string[] args) => new Thread(new Program().Solve, 1 << 27).Start();\n}\n\n// https://bitbucket.org/camypaper/complib\nnamespace CompLib.Mathematics\n{\n    #region ModInt\n\n    /// <summary>\n    /// [0,<see cref=\"Mod\"/>) \u307e\u3067\u306e\u5024\u3092\u53d6\u308b\u3088\u3046\u306a\u6570\n    /// </summary>\n    public struct ModInt\n    {\n        /// <summary>\n        /// \u5270\u4f59\u3092\u53d6\u308b\u5024\uff0e\n        /// </summary>\n        public const long Mod = (int) 1e9 + 7;\n        // public const long Mod = 998244353;\n\n        /// <summary>\n        /// \u5b9f\u969b\u306e\u6570\u5024\uff0e\n        /// </summary>\n        public long num;\n\n        /// <summary>\n        /// \u5024\u304c <paramref name=\"n\"/> \u3067\u3042\u308b\u3088\u3046\u306a\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u69cb\u7bc9\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"n\">\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u6301\u3064\u5024</param>\n        /// <remarks>\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u554f\u984c\u4e0a\uff0c\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5185\u3067\u306f\u5270\u4f59\u3092\u53d6\u308a\u307e\u305b\u3093\uff0e\u305d\u306e\u305f\u3081\uff0c<paramref name=\"n\"/> \u2208 [0,<see cref=\"Mod\"/>) \u3092\u6e80\u305f\u3059\u3088\u3046\u306a <paramref name=\"n\"/> \u3092\u6e21\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\u3053\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306f O(1) \u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\uff0e</remarks>\n        public ModInt(long n)\n        {\n            num = n;\n        }\n\n        /// <summary>\n        /// \u3053\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u6570\u5024\u3092\u6587\u5b57\u5217\u306b\u5909\u63db\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <returns>[0,<see cref=\"Mod\"/>) \u306e\u7bc4\u56f2\u5185\u306e\u6574\u6570\u3092 10 \u9032\u8868\u8a18\u3057\u305f\u3082\u306e\uff0e</returns>\n        public override string ToString()\n        {\n            return num.ToString();\n        }\n\n        public static ModInt operator +(ModInt l, ModInt r)\n        {\n            l.num += r.num;\n            if (l.num >= Mod) l.num -= Mod;\n            return l;\n        }\n\n        public static ModInt operator -(ModInt l, ModInt r)\n        {\n            l.num -= r.num;\n            if (l.num < 0) l.num += Mod;\n            return l;\n        }\n\n        public static ModInt operator *(ModInt l, ModInt r)\n        {\n            return new ModInt(l.num * r.num % Mod);\n        }\n\n        public static implicit operator ModInt(long n)\n        {\n            n %= Mod;\n            if (n < 0) n += Mod;\n            return new ModInt(n);\n        }\n\n        /// <summary>\n        /// \u4e0e\u3048\u3089\u308c\u305f 2 \u3064\u306e\u6570\u5024\u304b\u3089\u3079\u304d\u5270\u4f59\u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"v\">\u3079\u304d\u4e57\u306e\u5e95</param>\n        /// <param name=\"k\">\u3079\u304d\u6307\u6570</param>\n        /// <returns>\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\u306b\u3088\u308a O(N log N) \u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\uff0e</returns>\n        public static ModInt Pow(ModInt v, long k)\n        {\n            return Pow(v.num, k);\n        }\n\n        /// <summary>\n        /// \u4e0e\u3048\u3089\u308c\u305f 2 \u3064\u306e\u6570\u5024\u304b\u3089\u3079\u304d\u5270\u4f59\u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"v\">\u3079\u304d\u4e57\u306e\u5e95</param>\n        /// <param name=\"k\">\u3079\u304d\u6307\u6570</param>\n        /// <returns>\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\u306b\u3088\u308a O(N log N) \u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\uff0e</returns>\n        public static ModInt Pow(long v, long k)\n        {\n            long ret = 1;\n            for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n                if ((k & 1) == 1)\n                    ret = ret * v % Mod;\n            return new ModInt(ret);\n        }\n\n        /// <summary>\n        /// \u4e0e\u3048\u3089\u308c\u305f\u6570\u306e\u9006\u5143\u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"v\">\u9006\u5143\u3092\u53d6\u308b\u5bfe\u8c61\u3068\u306a\u308b\u6570</param>\n        /// <returns>\u9006\u5143\u3068\u306a\u308b\u3088\u3046\u306a\u5024</returns>\n        /// <remarks>\u6cd5\u304c\u7d20\u6570\u3067\u3042\u308b\u3053\u3068\u3092\u4eee\u5b9a\u3057\u3066\uff0c\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\u306b\u5f93\u3063\u3066\u9006\u5143\u3092 O(log N) \u3067\u8a08\u7b97\u3057\u307e\u3059\uff0e</remarks>\n        public static ModInt Inverse(ModInt v)\n        {\n            return Pow(v, Mod - 2);\n        }\n    }\n\n    #endregion\n\n    #region Binomial Coefficient\n\n    public class BinomialCoefficient\n    {\n        public ModInt[] fact, ifact;\n\n        public BinomialCoefficient(int n)\n        {\n            fact = new ModInt[n + 1];\n            ifact = new ModInt[n + 1];\n            fact[0] = 1;\n            for (int i = 1; i <= n; i++)\n                fact[i] = fact[i - 1] * i;\n            ifact[n] = ModInt.Inverse(fact[n]);\n            for (int i = n - 1; i >= 0; i--)\n                ifact[i] = ifact[i + 1] * (i + 1);\n            ifact[0] = ifact[1];\n        }\n\n        public ModInt this[int n, int r]\n        {\n            get\n            {\n                if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n                return fact[n] * ifact[n - r] * ifact[r];\n            }\n        }\n\n        public ModInt RepeatedCombination(int n, int k)\n        {\n            if (k == 0) return 1;\n            return this[n + k - 1, k];\n        }\n    }\n\n    #endregion\n}\n\n\nnamespace CompLib.Util\n{\n    using System;\n    using System.Linq;\n\n    class Scanner\n    {\n        private string[] _line;\n        private int _index;\n        private const char Separator = ' ';\n\n        public Scanner()\n        {\n            _line = new string[0];\n            _index = 0;\n        }\n\n        public string Next()\n        {\n            if (_index >= _line.Length)\n            {\n                string s;\n                do\n                {\n                    s = Console.ReadLine();\n                } while (s.Length == 0);\n\n                _line = s.Split(Separator);\n                _index = 0;\n            }\n\n            return _line[_index++];\n        }\n\n        public string ReadLine()\n        {\n            _index = _line.Length;\n            return Console.ReadLine();\n        }\n\n        public int NextInt() => int.Parse(Next());\n        public long NextLong() => long.Parse(Next());\n        public double NextDouble() => double.Parse(Next());\n        public decimal NextDecimal() => decimal.Parse(Next());\n        public char NextChar() => Next()[0];\n        public char[] NextCharArray() => Next().ToCharArray();\n\n        public string[] Array()\n        {\n            string s = Console.ReadLine();\n            _line = s.Length == 0 ? new string[0] : s.Split(Separator);\n            _index = _line.Length;\n            return _line;\n        }\n\n        public int[] IntArray() => Array().Select(int.Parse).ToArray();\n        public long[] LongArray() => Array().Select(long.Parse).ToArray();\n        public double[] DoubleArray() => Array().Select(double.Parse).ToArray();\n        public decimal[] DecimalArray() => Array().Select(decimal.Parse).ToArray();\n    }\n}\n\nProvide the fixed C# code without any description or extra tokens.\n\nFixed source code:",
            ""
        ]
    },
    "source_data": {
        "delete_cnt": 0,
        "fix_code_uid": "",
        "difficulty": 1500,
        "replace_cnt": 0,
        "fix_ops_cnt": 1,
        "prob_desc_output_spec": "Print a single number\u00a0\u2014 the remainder of the division of the number of valid permutations by $$$10^9+7$$$.",
        "apr_id": "b6a19fa11ea04dfcfafe609115529df4",
        "bug_source_code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing CompLib.Util;\nusing System.Threading;\nusing CompLib.Mathematics;\n\npublic class Program\n{\n    private int N, X, Pos;\n\n    public void Solve()\n    {\n        var sc = new Scanner();\n        N = sc.NextInt();\n        X = sc.NextInt();\n        Pos = sc.NextInt();\n\n        List<int> g = new List<int>();\n        List<int> l = new List<int>();\n        int left = 0;\n        int right = N;\n        while (left < right)\n        {\n            int middle = (left + right) / 2;\n            if (middle <= Pos)\n            {\n                l.Add(middle);\n                left = middle + 1;\n            }\n            else\n            {\n                g.Add(middle);\n                right = middle;\n            }\n        }\n\n        // x\u672a\u6e80 len(l)-1\u500b\n        // x\u8d85\u904e len(g)\u500b\n\n        // \u306e\u3053\u308a\u3066\u304d\u3068\u3046\n\n        var c = new BinomialCoefficient(5000);\n        ModInt ans = c.fact[X - 1] * c.ifact[(X - 1) - (l.Count - 1)];\n        ans *= c.fact[N - X] * c.ifact[(N - X) - g.Count];\n        ans *= c.fact[N - (l.Count + g.Count)];\n        Console.WriteLine(ans);\n    }\n\n    public static void Main(string[] args) => new Program().Solve();\n    // public static void Main(string[] args) => new Thread(new Program().Solve, 1 << 27).Start();\n}\n\n// https://bitbucket.org/camypaper/complib\nnamespace CompLib.Mathematics\n{\n    #region ModInt\n\n    /// <summary>\n    /// [0,<see cref=\"Mod\"/>) \u307e\u3067\u306e\u5024\u3092\u53d6\u308b\u3088\u3046\u306a\u6570\n    /// </summary>\n    public struct ModInt\n    {\n        /// <summary>\n        /// \u5270\u4f59\u3092\u53d6\u308b\u5024\uff0e\n        /// </summary>\n        public const long Mod = (int) 1e9 + 7;\n        // public const long Mod = 998244353;\n\n        /// <summary>\n        /// \u5b9f\u969b\u306e\u6570\u5024\uff0e\n        /// </summary>\n        public long num;\n\n        /// <summary>\n        /// \u5024\u304c <paramref name=\"n\"/> \u3067\u3042\u308b\u3088\u3046\u306a\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u3092\u69cb\u7bc9\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"n\">\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u304c\u6301\u3064\u5024</param>\n        /// <remarks>\u30d1\u30d5\u30a9\u30fc\u30de\u30f3\u30b9\u306e\u554f\u984c\u4e0a\uff0c\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u5185\u3067\u306f\u5270\u4f59\u3092\u53d6\u308a\u307e\u305b\u3093\uff0e\u305d\u306e\u305f\u3081\uff0c<paramref name=\"n\"/> \u2208 [0,<see cref=\"Mod\"/>) \u3092\u6e80\u305f\u3059\u3088\u3046\u306a <paramref name=\"n\"/> \u3092\u6e21\u3057\u3066\u304f\u3060\u3055\u3044\uff0e\u3053\u306e\u30b3\u30f3\u30b9\u30c8\u30e9\u30af\u30bf\u306f O(1) \u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\uff0e</remarks>\n        public ModInt(long n)\n        {\n            num = n;\n        }\n\n        /// <summary>\n        /// \u3053\u306e\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u306e\u6570\u5024\u3092\u6587\u5b57\u5217\u306b\u5909\u63db\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <returns>[0,<see cref=\"Mod\"/>) \u306e\u7bc4\u56f2\u5185\u306e\u6574\u6570\u3092 10 \u9032\u8868\u8a18\u3057\u305f\u3082\u306e\uff0e</returns>\n        public override string ToString()\n        {\n            return num.ToString();\n        }\n\n        public static ModInt operator +(ModInt l, ModInt r)\n        {\n            l.num += r.num;\n            if (l.num >= Mod) l.num -= Mod;\n            return l;\n        }\n\n        public static ModInt operator -(ModInt l, ModInt r)\n        {\n            l.num -= r.num;\n            if (l.num < 0) l.num += Mod;\n            return l;\n        }\n\n        public static ModInt operator *(ModInt l, ModInt r)\n        {\n            return new ModInt(l.num * r.num % Mod);\n        }\n\n        public static implicit operator ModInt(long n)\n        {\n            n %= Mod;\n            if (n < 0) n += Mod;\n            return new ModInt(n);\n        }\n\n        /// <summary>\n        /// \u4e0e\u3048\u3089\u308c\u305f 2 \u3064\u306e\u6570\u5024\u304b\u3089\u3079\u304d\u5270\u4f59\u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"v\">\u3079\u304d\u4e57\u306e\u5e95</param>\n        /// <param name=\"k\">\u3079\u304d\u6307\u6570</param>\n        /// <returns>\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\u306b\u3088\u308a O(N log N) \u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\uff0e</returns>\n        public static ModInt Pow(ModInt v, long k)\n        {\n            return Pow(v.num, k);\n        }\n\n        /// <summary>\n        /// \u4e0e\u3048\u3089\u308c\u305f 2 \u3064\u306e\u6570\u5024\u304b\u3089\u3079\u304d\u5270\u4f59\u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"v\">\u3079\u304d\u4e57\u306e\u5e95</param>\n        /// <param name=\"k\">\u3079\u304d\u6307\u6570</param>\n        /// <returns>\u7e70\u308a\u8fd4\u3057\u4e8c\u4e57\u6cd5\u306b\u3088\u308a O(N log N) \u3067\u5b9f\u884c\u3055\u308c\u307e\u3059\uff0e</returns>\n        public static ModInt Pow(long v, long k)\n        {\n            long ret = 1;\n            for (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n                if ((k & 1) == 1)\n                    ret = ret * v % Mod;\n            return new ModInt(ret);\n        }\n\n        /// <summary>\n        /// \u4e0e\u3048\u3089\u308c\u305f\u6570\u306e\u9006\u5143\u3092\u8a08\u7b97\u3057\u307e\u3059\uff0e\n        /// </summary>\n        /// <param name=\"v\">\u9006\u5143\u3092\u53d6\u308b\u5bfe\u8c61\u3068\u306a\u308b\u6570</param>\n        /// <returns>\u9006\u5143\u3068\u306a\u308b\u3088\u3046\u306a\u5024</returns>\n        /// <remarks>\u6cd5\u304c\u7d20\u6570\u3067\u3042\u308b\u3053\u3068\u3092\u4eee\u5b9a\u3057\u3066\uff0c\u30d5\u30a7\u30eb\u30de\u30fc\u306e\u5c0f\u5b9a\u7406\u306b\u5f93\u3063\u3066\u9006\u5143\u3092 O(log N) \u3067\u8a08\u7b97\u3057\u307e\u3059\uff0e</remarks>\n        public static ModInt Inverse(ModInt v)\n        {\n            return Pow(v, Mod - 2);\n        }\n    }\n\n    #endregion\n\n    #region Binomial Coefficient\n\n    public class BinomialCoefficient\n    {\n        public ModInt[] fact, ifact;\n\n        public BinomialCoefficient(int n)\n        {\n            fact = new ModInt[n + 1];\n            ifact = new ModInt[n + 1];\n            fact[0] = 1;\n            for (int i = 1; i <= n; i++)\n                fact[i] = fact[i - 1] * i;\n            ifact[n] = ModInt.Inverse(fact[n]);\n            for (int i = n - 1; i >= 0; i--)\n                ifact[i] = ifact[i + 1] * (i + 1);\n            ifact[0] = ifact[1];\n        }\n\n        public ModInt this[int n, int r]\n        {\n            get\n            {\n                if (n < 0 || n >= fact.Length || r < 0 || r > n) return 0;\n                return fact[n] * ifact[n - r] * ifact[r];\n            }\n        }\n\n        public ModInt RepeatedCombination(int n, int k)\n        {\n            if (k == 0) return 1;\n            return this[n + k - 1, k];\n        }\n    }\n\n    #endregion\n}\n\n\nnamespace CompLib.Util\n{\n    using System;\n    using System.Linq;\n\n    class Scanner\n    {\n        private string[] _line;\n        private int _index;\n        private const char Separator = ' ';\n\n        public Scanner()\n        {\n            _line = new string[0];\n            _index = 0;\n        }\n\n        public string Next()\n        {\n            if (_index >= _line.Length)\n            {\n                string s;\n                do\n                {\n                    s = Console.ReadLine();\n                } while (s.Length == 0);\n\n                _line = s.Split(Separator);\n                _index = 0;\n            }\n\n            return _line[_index++];\n        }\n\n        public string ReadLine()\n        {\n            _index = _line.Length;\n            return Console.ReadLine();\n        }\n\n        public int NextInt() => int.Parse(Next());\n        public long NextLong() => long.Parse(Next());\n        public double NextDouble() => double.Parse(Next());\n        public decimal NextDecimal() => decimal.Parse(Next());\n        public char NextChar() => Next()[0];\n        public char[] NextCharArray() => Next().ToCharArray();\n\n        public string[] Array()\n        {\n            string s = Console.ReadLine();\n            _line = s.Length == 0 ? new string[0] : s.Split(Separator);\n            _index = _line.Length;\n            return _line;\n        }\n\n        public int[] IntArray() => Array().Select(int.Parse).ToArray();\n        public long[] LongArray() => Array().Select(long.Parse).ToArray();\n        public double[] DoubleArray() => Array().Select(double.Parse).ToArray();\n        public decimal[] DecimalArray() => Array().Select(decimal.Parse).ToArray();\n    }\n}",
        "prob_desc_input_spec": "The only line of input contains integers $$$n$$$, $$$x$$$ and $$$pos$$$ ($$$1 \\le x \\le n \\le 1000$$$, $$$0 \\le pos \\le n - 1$$$) \u2014 the required length of the permutation, the number to search, and the required position of that number, respectively.",
        "src_uid": "24e2f10463f440affccc2755f4462d8a",
        "bug_code_uid": "8e7f2c6d95d8bf5a67f46edca33c4760",
        "equal_cnt": 2,
        "prob_desc_time_limit": "1 second",
        "similarity_score": 0.9882944226264954,
        "bug_exec_outcome": "RUNTIME_ERROR",
        "lang_cluster": "C#",
        "potential_dominant_fix_op": "insert",
        "prob_desc_sample_inputs": [
            "4 1 2",
            "123 42 24"
        ],
        "prob_desc_input_from": "standard input",
        "prob_desc_description": "Andrey thinks he is truly a successful developer, but in reality he didn't know about the binary search algorithm until recently. After reading some literature Andrey understood that this algorithm allows to quickly find a certain number $$$x$$$ in an array. For an array $$$a$$$ indexed from zero, and an integer $$$x$$$ the pseudocode of the algorithm is as follows:  Note that the elements of the array are indexed from zero, and the division is done in integers (rounding down).Andrey read that the algorithm only works if the array is sorted. However, he found this statement untrue, because there certainly exist unsorted arrays for which the algorithm find $$$x$$$!Andrey wants to write a letter to the book authors, but before doing that he must consider the permutations of size $$$n$$$ such that the algorithm finds $$$x$$$ in them. A permutation of size $$$n$$$ is an array consisting of $$$n$$$ distinct integers between $$$1$$$ and $$$n$$$ in arbitrary order.Help Andrey and find the number of permutations of size $$$n$$$ which contain $$$x$$$ at position $$$pos$$$ and for which the given implementation of the binary search algorithm finds $$$x$$$ (returns true). As the result may be extremely large, print the remainder of its division by $$$10^9+7$$$.",
        "lang": ".NET Core C#",
        "fix_exec_outcome": "",
        "insert_cnt": 1,
        "fix_source_code": "",
        "prob_desc_notes": "NoteAll possible permutations in the first test case: $$$(2, 3, 1, 4)$$$, $$$(2, 4, 1, 3)$$$, $$$(3, 2, 1, 4)$$$, $$$(3, 4, 1, 2)$$$, $$$(4, 2, 1, 3)$$$, $$$(4, 3, 1, 2)$$$.",
        "file_name": "C#.jsonl",
        "tags": [
            "combinatorics",
            "binary search"
        ],
        "prob_desc_output_to": "standard output",
        "prob_desc_created_at": "1603548300",
        "prob_desc_memory_limit": "256 megabytes",
        "prob_desc_sample_outputs": [
            "6",
            "824071958"
        ],
        "hidden_unit_tests": "[{\"input\": \"4 1 2\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"123 42 24\\r\\n\", \"output\": [\"824071958\"]}, {\"input\": \"1 1 0\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"1000 501 501\\r\\n\", \"output\": [\"646597996\"]}, {\"input\": \"1000 999 799\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 1 1\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"2 2 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"3 1 2\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"3 2 2\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"3 3 1\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"4 2 0\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"4 3 2\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"4 4 3\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"7 1 1\\r\\n\", \"output\": [\"720\"]}, {\"input\": \"7 7 6\\r\\n\", \"output\": [\"720\"]}, {\"input\": \"7 2 4\\r\\n\", \"output\": [\"120\"]}, {\"input\": \"7 4 4\\r\\n\", \"output\": [\"216\"]}, {\"input\": \"8 4 1\\r\\n\", \"output\": [\"1440\"]}, {\"input\": \"8 1 5\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"8 8 7\\r\\n\", \"output\": [\"5040\"]}, {\"input\": \"8 7 6\\r\\n\", \"output\": [\"720\"]}, {\"input\": \"8 3 0\\r\\n\", \"output\": [\"1440\"]}, {\"input\": \"9 1 7\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"9 9 5\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"9 5 5\\r\\n\", \"output\": [\"5760\"]}, {\"input\": \"9 4 4\\r\\n\", \"output\": [\"7200\"]}, {\"input\": \"9 3 3\\r\\n\", \"output\": [\"8640\"]}, {\"input\": \"10 1 1\\r\\n\", \"output\": [\"362880\"]}, {\"input\": \"10 10 9\\r\\n\", \"output\": [\"362880\"]}, {\"input\": \"10 5 5\\r\\n\", \"output\": [\"43200\"]}, {\"input\": \"10 3 7\\r\\n\", \"output\": [\"70560\"]}, {\"input\": \"10 4 4\\r\\n\", \"output\": [\"90720\"]}, {\"input\": \"10 6 6\\r\\n\", \"output\": [\"43200\"]}, {\"input\": \"10 7 7\\r\\n\", \"output\": [\"90720\"]}, {\"input\": \"10 9 5\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"74 16 54\\r\\n\", \"output\": [\"625981152\"]}, {\"input\": \"63 15 45\\r\\n\", \"output\": [\"581829795\"]}, {\"input\": \"54 4 47\\r\\n\", \"output\": [\"911648281\"]}, {\"input\": \"92 22 62\\r\\n\", \"output\": [\"628152721\"]}, {\"input\": \"82 15 14\\r\\n\", \"output\": [\"187724629\"]}, {\"input\": \"91 60 48\\r\\n\", \"output\": [\"233776714\"]}, {\"input\": \"91 51 5\\r\\n\", \"output\": [\"660447677\"]}, {\"input\": \"70 45 16\\r\\n\", \"output\": [\"578976138\"]}, {\"input\": \"61 21 16\\r\\n\", \"output\": [\"516359078\"]}, {\"input\": \"61 29 15\\r\\n\", \"output\": [\"252758304\"]}, {\"input\": \"69 67 68\\r\\n\", \"output\": [\"736622722\"]}, {\"input\": \"59 40 1\\r\\n\", \"output\": [\"384105577\"]}, {\"input\": \"98 86 39\\r\\n\", \"output\": [\"132656801\"]}, {\"input\": \"97 89 29\\r\\n\", \"output\": [\"673334741\"]}, {\"input\": \"78 66 16\\r\\n\", \"output\": [\"703501645\"]}, {\"input\": \"777 254 720\\r\\n\", \"output\": [\"57449468\"]}, {\"input\": \"908 216 521\\r\\n\", \"output\": [\"601940707\"]}, {\"input\": \"749 158 165\\r\\n\", \"output\": [\"849211382\"]}, {\"input\": \"535 101 250\\r\\n\", \"output\": [\"111877808\"]}, {\"input\": \"665 5 305\\r\\n\", \"output\": [\"400272219\"]}, {\"input\": \"856 406 675\\r\\n\", \"output\": [\"663368144\"]}, {\"input\": \"697 390 118\\r\\n\", \"output\": [\"844062514\"]}, {\"input\": \"539 246 0\\r\\n\", \"output\": [\"410139856\"]}, {\"input\": \"669 380 461\\r\\n\", \"output\": [\"921432102\"]}, {\"input\": \"954 325 163\\r\\n\", \"output\": [\"917113541\"]}, {\"input\": \"646 467 58\\r\\n\", \"output\": [\"214437899\"]}, {\"input\": \"542 427 258\\r\\n\", \"output\": [\"830066531\"]}, {\"input\": \"562 388 191\\r\\n\", \"output\": [\"935998075\"]}, {\"input\": \"958 817 269\\r\\n\", \"output\": [\"513948977\"]}, {\"input\": \"1000 888 888\\r\\n\", \"output\": [\"644649893\"]}, {\"input\": \"1000 2 2\\r\\n\", \"output\": [\"22779421\"]}, {\"input\": \"534 376 180\\r\\n\", \"output\": [\"984450056\"]}, {\"input\": \"1000 1 1\\r\\n\", \"output\": [\"756641425\"]}, {\"input\": \"1000 3 3\\r\\n\", \"output\": [\"606772288\"]}, {\"input\": \"1000 500 500\\r\\n\", \"output\": [\"646597996\"]}, {\"input\": \"1000 1000 999\\r\\n\", \"output\": [\"756641425\"]}, {\"input\": \"1000 501 50\\r\\n\", \"output\": [\"636821580\"]}, {\"input\": \"6 4 3\\r\\n\", \"output\": [\"12\"]}, {\"input\": \"3 2 1\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"100 5 50\\r\\n\", \"output\": [\"469732450\"]}, {\"input\": \"999 490 499\\r\\n\", \"output\": [\"998308393\"]}, {\"input\": \"7 3 3\\r\\n\", \"output\": [\"288\"]}, {\"input\": \"10 7 5\\r\\n\", \"output\": [\"4320\"]}, {\"input\": \"123 1 24\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"5 5 2\\r\\n\", \"output\": [\"0\"]}]"
    }
}