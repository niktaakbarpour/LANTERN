{
    "oai_response": {
        "choices": [
            {
                "message": {
                    "role": "assistant",
                    "content": "```C#\nusing System;\n\npublic class Source\n{\n    public static void Main()\n    {\n        int n = int.Parse(Console.ReadLine());\n\n        int a = (int)Math.Sqrt(n);\n        int b = n / a;\n\n        while(a * b < n)\n        {\n            if(a < b)\n                a++;\n            else\n                b++;\n        }\n\n        Console.WriteLine(a + \" \" + b);\n    }\n}\n```"
                }
            }
        ],
        "prompt": [
            "Fix a buggy program written in C# language to solve the following programming problem:\nDescription: A big company decided to launch a new series of rectangular displays, and decided that the display must have exactly n pixels. Your task is to determine the size of the rectangular display \u2014 the number of lines (rows) of pixels a and the number of columns of pixels b, so that:  there are exactly n pixels on the display;  the number of rows does not exceed the number of columns, it means a\u2009\u2264\u2009b;  the difference b\u2009-\u2009a is as small as possible. \nInput Specification: The first line contains the positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106)\u00a0\u2014 the number of pixels display should have.\nOutput Specification: Print two integers\u00a0\u2014 the number of rows and columns on the display. \n\nSample Input:\n8\nSample Output:\n2 4\n\nSample Input:\n64\nSample Output:\n8 8\n\nSample Input:\n5\nSample Output:\n1 5\n\nSample Input:\n999999\nSample Output:\n999 1001\n\nNotes: NoteIn the first example the minimum possible difference equals 2, so on the display should be 2 rows of 4 pixels.In the second example the minimum possible difference equals 0, so on the display should be 8 rows of 8 pixels.In the third example the minimum possible difference equals 4, so on the display should be 1 row of 5 pixels.\nTake input from standard input and output to standard output\n\nHere is the code with a bug of WRONG_ANSWER:\n\nusing System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\npublic class Source\n{\n    public void Program()\n    {\n\n    }\n    void Read()\n    {\n        int n = ri();\n        writeLine(1 + \" \" + n);\n    }\n\n    #region hide it\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n            reader = new StreamReader(Console.OpenStandardInput());\n            writer = new StreamWriter(Console.OpenStandardOutput());\n            //reader = new StreamReader(\"input.txt\");\n            //writer = new StreamWriter(\"output.txt\");\n#endif\n        var source = new Source();\n        source.Read();\n        source.Program();\n\n        /* try\n         {\n             new Source().Program();\n         }\n         catch (Exception ex)\n         {\n #if DEBUG\n             Console.WriteLine(ex);\n #else\n             throw;\n #endif\n         }*/\n        reader.Close();\n        writer.Close();\n    }\n\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken()\n    {\n        while (currentLineTokens.Count == 0)\n            currentLineTokens = new Queue<string>(ReadAndSplitLine());\n        return currentLineTokens.Dequeue();\n    }\n    public static int ri() { return int.Parse(ReadToken()); }\n    public static char ReadChar() { return char.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static ulong ReaduLong() { return ulong.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(i => int.Parse(i)).ToArray(); }\n    public static char[] ReadCharArray() { return ReadAndSplitLine().Select(i => char.Parse(i)).ToArray(); }\n    public static char[] SplitToChar() { string s = ReadToken(); char[] r = new char[s.Length]; for (int i = 0; i < s.Length; i++) r[i] = s[i]; return r; }\n    public static byte[] SplitToByte() { string s = ReadToken(); byte[] r = new byte[s.Length]; for (int i = 0; i < s.Length; i++) r[i] = (byte)s[i]; return r; }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++) matrix[i] = ReadIntArray(); return matrix; }\n    public static char[][] ReadCharMatrix(int numberOfRows) { char[][] matrix = new char[numberOfRows][]; for (int i = 0; i < numberOfRows; i++) matrix[i] = ReadCharArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++) ret[i][j] = matrix[j][i]; }\n        return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++) lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void write<T>(T value) { writer.Write(value); }\n    public static void writeLine<T>(T value) { writer.WriteLine(value); }\n    public static void writeArray<T>(T[] array, string split) { for (int i = 0; i < array.Length; i++) { write(array[i] + split); } }\n    public static void writeMatrix<T>(T[][] matrix, string split) { for (int i = 0; i < matrix.Length; i++) { writeArray(matrix[i], split); writer.Write(\"\\n\"); } }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++) ret[i] = new T(); return ret; }\n    #endregion\n\n    #region Methods\n    #region DSU\n    public void MakeSet(int[] poi)\n    {\n        for (int i = 0; i < poi.Length; i++)\n        {\n            poi[i] = i;\n        }\n    }\n    public int Find(int x, int[] poi)\n    {\n        if (poi[x] == x) return x;\n        return poi[x] = Find(poi[x], poi);\n    }\n    Random rand = new Random();\n    public void Unite(int x, int y, int[] poi)\n    {\n        y = Find(y, poi);\n        x = Find(x, poi);\n        if (rand.Next() % 2 == 0)\n            Swap(ref x, ref y);\n        poi[x] = y;\n    }\n    #endregion\n\n    class Deque<T>\n    {\n        T[] array;\n        int start, length;\n        public Deque()\n        {\n            start = 0; length = 0; array = new T[1];\n        }\n        public T this[int index] { get { return array[(start + index) % array.Length]; } set { array[(start + index) % array.Length] = value; } }\n        int last { get { return (start + length) % array.Length; } }\n        /// <summary>\n        /// \u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u0081\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00c2\u00a2\u00c3\u00a2\u00e2\u0080\u009a\u00c2\u00ac\u00c3\n        /// </summary>\n        public T PeekFirst()\n        {\n            return array[start];\n        }\n        public int Count { get { return length; } }\n        /// <summary>\n        /// \u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00ba\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00be\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bd\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00c2\u00a2\u00c3\u00a2\u00e2\u0080\u009a\u00c2\u00ac  \u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b1\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b7 \u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080 \u00c3\u00a2\u00e2\u0082\u00ac\u00e2\u0084\u00a2\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b4\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b0\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bb\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bd\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b8\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u008f\n        /// </summary>\n        public T PeekLsat()\n        {\n            return array[last];\n        }\n        public T PopLast()\n        {\n            if (length == 0)\n                throw new IndexOutOfRangeException(\"OutOfRange\");\n            length--;\n            return array[last];\n        }\n        public T PopFirst()\n        {\n            if (length == 0)\n                throw new IndexOutOfRangeException(\"OutOfRange\");\n            length--;\n            if (start >= array.Length - 1) start = 0; else start++;\n            return array[start - 1 < 0 ? array.Length - 1 : start - 1];\n        }\n        public void AddFirst(T value)\n        {\n            IncreaseAndInspection();\n            if (start <= 0) start = array.Length - 1; else start--;\n            array[start] = value;\n            length++;\n        }\n        public void AddLast(T value)\n        {\n            IncreaseAndInspection();\n            array[last] = value;\n            length++;\n        }\n        bool overflow { get { return length == array.Length; } }\n        void IncreaseAndInspection()\n        {\n            if (overflow)\n                increase();\n\n        }\n        void increase()\n        {\n            T[] array2 = new T[array.Length * 2];\n            for (int i = 0; i < array.Length; i++)\n            {\n                int pos = (start + i) % array.Length;\n                array2[i] = array[pos];\n            }\n            array = array2;\n            start = 0;\n            array2 = null;\n        }\n        public void Clear()\n        {\n            start = 0; length = 0; array = new T[1];\n        }\n    }\n    class Heap<T>\n    {\n        Comparison<T> ic;\n        List<T> storage = new List<T>();\n        public Heap(Comparison<T> ic)\n        {\n            this.ic = ic;\n        }\n        public void Add(T element)\n        {\n            storage.Add(element);\n            int pos = storage.Count - 1;\n            while (pos != 0 && ic(storage[((int)(pos - 1) >> 1)], element) > 0)\n            {\n                Swap(storage, pos, ((int)(pos - 1) / 2));\n                pos = ((int)(pos - 1) / 2);\n            }\n        }\n        public T Pop()\n        {\n            T t = storage[0];\n            Swap(storage, 0, storage.Count - 1);\n            int pos = 0;\n            storage.RemoveAt(storage.Count - 1);\n            if (Count > 0)\n                while (true)\n                {\n                    T my = storage[pos];\n                    if (pos * 2 + 1 >= Count)\n                        break;\n                    T left = storage[pos * 2 + 1];\n                    if (pos * 2 + 2 >= Count)\n                    {\n                        if (ic(left, my) < 0)\n                        {\n                            Swap(storage, pos, pos * 2 + 1);\n                            pos = pos * 2 + 1;\n                        }\n                        break;\n                    }\n                    T right = storage[pos * 2 + 2];\n                    if (ic(left, my) < 0 || ic(right, my) < 0)\n                    {\n                        if (ic(left, right) < 0)\n                        {\n                            Swap(storage, pos, pos * 2 + 1);\n                            pos = pos * 2 + 1;\n                        }\n                        else\n                        {\n\n                            Swap(storage, pos, pos * 2 + 2);\n                            pos = pos * 2 + 2;\n                        }\n                    }\n                    else break;\n                }\n            return t;\n        }\n\n        public void Clear()\n        {\n            storage.Clear();\n        }\n        /// <summary>\n        /// \u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b1\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b7 \u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080 \u00c3\u00a2\u00e2\u0082\u00ac\u00e2\u0084\u00a2\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b4\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b0\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bb\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bd\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b8\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u008f\n        /// </summary>\n        /// <returns></returns>\n        public T Peek()\n        {\n            return storage[0];\n        }\n        public int Count\n        {\n            get { return storage.Count; }\n        }\n        //void RemoveLast, Size, peeklast, add\n    }\n    static void Swap<T>(ref T lhs, ref T rhs)\n    {\n        T temp;\n        temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n    }\n    static void Swap<T>(T[] a, int l, int r)\n    {\n        T temp;\n        temp = a[l];\n        a[l] = a[r];\n        a[r] = temp;\n    }\n    static void Swap<T>(List<T> a, int l, int r)\n    {\n        T temp;\n        temp = a[l];\n        a[l] = a[r];\n        a[r] = temp;\n    }\n\n    bool outregion(long y, long x, long n, long m)\n    {\n        if (x < 0 || x >= m || y < 0 || y >= n)\n            return true;\n        return false;\n    }\n    static void initlist<T>(ref List<T>[] list, int n)\n    {\n        list = new List<T>[n];\n        for (int i = 0; i < n; i++)\n            list[i] = new List<T>();\n    }\n    static void newarray<T>(ref T[][] array, int n, int m)\n    {\n        array = new T[n][];\n        for (int i = 0; i < n; i++)\n            array[i] = new T[m];\n    }\n    static void newarray<T>(ref T[] array, int n)\n    {\n        array = new T[n];\n    }\n    static void fill<T>(T[] array, T value)\n    {\n        for (int i = 0; i < array.Length; i++)\n            array[i] = value;\n    }\n    static void fill<T>(T[][] array, T value)\n    {\n        for (int i = 0; i < array.Length; i++)\n            for (int j = 0; j < array[i].Length; j++)\n                array[i][j] = value;\n    }\n    public bool NextPermutation<T>(T[] b, Comparison<T> ic)\n    {\n        for (int j = b.Length - 2; j >= 0; j--)\n        {\n            if (ic(b[j], b[j + 1]) < 0)\n            {\n                for (int l = b.Length - 1; l >= 0; l--)\n                {\n                    if (ic(b[l], b[j]) > 0)\n                    {\n                        Swap(b, j, l);\n                        Array.Reverse(b, j + 1, b.Length - (j + 1));\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    int[,] step8 = new int[,]\n    {\n        {-1,0 },\n        {1,0 },\n        {0,-1 },\n        {0,1 },\n        {1,1 },\n        {-1,1 },\n        {-1,-1 },\n        {1,-1 },\n    };\n    int[,] step4 = new int[,]\n    {\n        {-1,0 },\n        {1,0 },\n        {0,-1 },\n        {0,1 },\n    };\n    struct Vector2\n    {\n        public double x;\n        public double y;\n        public Vector2(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n        public double Dist(Vector2 to)\n        {\n            return Math.Sqrt(Math.Abs(Math.Pow(to.x - x, 2)) + Math.Abs(Math.Pow(to.y - y, 2)));\n        }\n        public static bool operator ==(Vector2 left, Vector2 right) { return left.x == right.x && left.y == right.y; }\n        public static bool operator !=(Vector2 left, Vector2 right) { return left.x != right.x || left.y != right.y; }\n    }\n    #endregion\n    #endregion\n\n}\n\n\nProvide the fixed C# code without any description or extra tokens.\n\nFixed source code:",
            ""
        ]
    },
    "source_data": {
        "delete_cnt": 0,
        "fix_code_uid": "",
        "difficulty": 800,
        "replace_cnt": 2,
        "fix_ops_cnt": 3,
        "prob_desc_output_spec": "Print two integers\u00a0\u2014 the number of rows and columns on the display. ",
        "apr_id": "f8fb7e5c0fb72e88186d518450a7b57f",
        "bug_source_code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\npublic class Source\n{\n    public void Program()\n    {\n\n    }\n    void Read()\n    {\n        int n = ri();\n        writeLine(1 + \" \" + n);\n    }\n\n    #region hide it\n    #region Main\n\n    protected static TextReader reader;\n    protected static TextWriter writer;\n    static void Main()\n    {\n#if DEBUG\n        reader = new StreamReader(\"..\\\\..\\\\input.txt\");\n        //reader = new StreamReader(Console.OpenStandardInput());\n        writer = Console.Out;\n        //writer = new StreamWriter(\"..\\\\..\\\\output.txt\");\n#else\n            reader = new StreamReader(Console.OpenStandardInput());\n            writer = new StreamWriter(Console.OpenStandardOutput());\n            //reader = new StreamReader(\"input.txt\");\n            //writer = new StreamWriter(\"output.txt\");\n#endif\n        var source = new Source();\n        source.Read();\n        source.Program();\n\n        /* try\n         {\n             new Source().Program();\n         }\n         catch (Exception ex)\n         {\n #if DEBUG\n             Console.WriteLine(ex);\n #else\n             throw;\n #endif\n         }*/\n        reader.Close();\n        writer.Close();\n    }\n\n\n    #endregion\n\n    #region Read / Write\n    private static Queue<string> currentLineTokens = new Queue<string>();\n    private static string[] ReadAndSplitLine() { return reader.ReadLine().Split(new[] { ' ', '\\t', }, StringSplitOptions.RemoveEmptyEntries); }\n    public static string ReadToken()\n    {\n        while (currentLineTokens.Count == 0)\n            currentLineTokens = new Queue<string>(ReadAndSplitLine());\n        return currentLineTokens.Dequeue();\n    }\n    public static int ri() { return int.Parse(ReadToken()); }\n    public static char ReadChar() { return char.Parse(ReadToken()); }\n    public static long ReadLong() { return long.Parse(ReadToken()); }\n    public static ulong ReaduLong() { return ulong.Parse(ReadToken()); }\n    public static double ReadDouble() { return double.Parse(ReadToken(), CultureInfo.InvariantCulture); }\n    public static int[] ReadIntArray() { return ReadAndSplitLine().Select(i => int.Parse(i)).ToArray(); }\n    public static char[] ReadCharArray() { return ReadAndSplitLine().Select(i => char.Parse(i)).ToArray(); }\n    public static char[] SplitToChar() { string s = ReadToken(); char[] r = new char[s.Length]; for (int i = 0; i < s.Length; i++) r[i] = s[i]; return r; }\n    public static byte[] SplitToByte() { string s = ReadToken(); byte[] r = new byte[s.Length]; for (int i = 0; i < s.Length; i++) r[i] = (byte)s[i]; return r; }\n    public static double[] ReadDoubleArray() { return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray(); }\n    public static int[][] ReadIntMatrix(int numberOfRows) { int[][] matrix = new int[numberOfRows][]; for (int i = 0; i < numberOfRows; i++) matrix[i] = ReadIntArray(); return matrix; }\n    public static char[][] ReadCharMatrix(int numberOfRows) { char[][] matrix = new char[numberOfRows][]; for (int i = 0; i < numberOfRows; i++) matrix[i] = ReadCharArray(); return matrix; }\n    public static int[][] ReadAndTransposeIntMatrix(int numberOfRows)\n    {\n        int[][] matrix = ReadIntMatrix(numberOfRows); int[][] ret = new int[matrix[0].Length][];\n        for (int i = 0; i < ret.Length; i++) { ret[i] = new int[numberOfRows]; for (int j = 0; j < numberOfRows; j++) ret[i][j] = matrix[j][i]; }\n        return ret;\n    }\n    public static string[] ReadLines(int quantity) { string[] lines = new string[quantity]; for (int i = 0; i < quantity; i++) lines[i] = reader.ReadLine().Trim(); return lines; }\n    public static void write<T>(T value) { writer.Write(value); }\n    public static void writeLine<T>(T value) { writer.WriteLine(value); }\n    public static void writeArray<T>(T[] array, string split) { for (int i = 0; i < array.Length; i++) { write(array[i] + split); } }\n    public static void writeMatrix<T>(T[][] matrix, string split) { for (int i = 0; i < matrix.Length; i++) { writeArray(matrix[i], split); writer.Write(\"\\n\"); } }\n    private class SDictionary<TKey, TValue> : Dictionary<TKey, TValue>\n    {\n        public new TValue this[TKey key]\n        {\n            get { return ContainsKey(key) ? base[key] : default(TValue); }\n            set { base[key] = value; }\n        }\n    }\n    private static T[] Init<T>(int size) where T : new() { var ret = new T[size]; for (int i = 0; i < size; i++) ret[i] = new T(); return ret; }\n    #endregion\n\n    #region Methods\n    #region DSU\n    public void MakeSet(int[] poi)\n    {\n        for (int i = 0; i < poi.Length; i++)\n        {\n            poi[i] = i;\n        }\n    }\n    public int Find(int x, int[] poi)\n    {\n        if (poi[x] == x) return x;\n        return poi[x] = Find(poi[x], poi);\n    }\n    Random rand = new Random();\n    public void Unite(int x, int y, int[] poi)\n    {\n        y = Find(y, poi);\n        x = Find(x, poi);\n        if (rand.Next() % 2 == 0)\n            Swap(ref x, ref y);\n        poi[x] = y;\n    }\n    #endregion\n\n    class Deque<T>\n    {\n        T[] array;\n        int start, length;\n        public Deque()\n        {\n            start = 0; length = 0; array = new T[1];\n        }\n        public T this[int index] { get { return array[(start + index) % array.Length]; } set { array[(start + index) % array.Length] = value; } }\n        int last { get { return (start + length) % array.Length; } }\n        /// <summary>\n        /// \u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u0081\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00c2\u00a2\u00c3\u00a2\u00e2\u0080\u009a\u00c2\u00ac\u00c3\n        /// </summary>\n        public T PeekFirst()\n        {\n            return array[start];\n        }\n        public int Count { get { return length; } }\n        /// <summary>\n        /// \u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00ba\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00be\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bd\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00c2\u00a2\u00c3\u00a2\u00e2\u0080\u009a\u00c2\u00ac  \u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b1\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b7 \u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080 \u00c3\u00a2\u00e2\u0082\u00ac\u00e2\u0084\u00a2\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b4\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b0\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bb\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bd\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b8\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u008f\n        /// </summary>\n        public T PeekLsat()\n        {\n            return array[last];\n        }\n        public T PopLast()\n        {\n            if (length == 0)\n                throw new IndexOutOfRangeException(\"OutOfRange\");\n            length--;\n            return array[last];\n        }\n        public T PopFirst()\n        {\n            if (length == 0)\n                throw new IndexOutOfRangeException(\"OutOfRange\");\n            length--;\n            if (start >= array.Length - 1) start = 0; else start++;\n            return array[start - 1 < 0 ? array.Length - 1 : start - 1];\n        }\n        public void AddFirst(T value)\n        {\n            IncreaseAndInspection();\n            if (start <= 0) start = array.Length - 1; else start--;\n            array[start] = value;\n            length++;\n        }\n        public void AddLast(T value)\n        {\n            IncreaseAndInspection();\n            array[last] = value;\n            length++;\n        }\n        bool overflow { get { return length == array.Length; } }\n        void IncreaseAndInspection()\n        {\n            if (overflow)\n                increase();\n\n        }\n        void increase()\n        {\n            T[] array2 = new T[array.Length * 2];\n            for (int i = 0; i < array.Length; i++)\n            {\n                int pos = (start + i) % array.Length;\n                array2[i] = array[pos];\n            }\n            array = array2;\n            start = 0;\n            array2 = null;\n        }\n        public void Clear()\n        {\n            start = 0; length = 0; array = new T[1];\n        }\n    }\n    class Heap<T>\n    {\n        Comparison<T> ic;\n        List<T> storage = new List<T>();\n        public Heap(Comparison<T> ic)\n        {\n            this.ic = ic;\n        }\n        public void Add(T element)\n        {\n            storage.Add(element);\n            int pos = storage.Count - 1;\n            while (pos != 0 && ic(storage[((int)(pos - 1) >> 1)], element) > 0)\n            {\n                Swap(storage, pos, ((int)(pos - 1) / 2));\n                pos = ((int)(pos - 1) / 2);\n            }\n        }\n        public T Pop()\n        {\n            T t = storage[0];\n            Swap(storage, 0, storage.Count - 1);\n            int pos = 0;\n            storage.RemoveAt(storage.Count - 1);\n            if (Count > 0)\n                while (true)\n                {\n                    T my = storage[pos];\n                    if (pos * 2 + 1 >= Count)\n                        break;\n                    T left = storage[pos * 2 + 1];\n                    if (pos * 2 + 2 >= Count)\n                    {\n                        if (ic(left, my) < 0)\n                        {\n                            Swap(storage, pos, pos * 2 + 1);\n                            pos = pos * 2 + 1;\n                        }\n                        break;\n                    }\n                    T right = storage[pos * 2 + 2];\n                    if (ic(left, my) < 0 || ic(right, my) < 0)\n                    {\n                        if (ic(left, right) < 0)\n                        {\n                            Swap(storage, pos, pos * 2 + 1);\n                            pos = pos * 2 + 1;\n                        }\n                        else\n                        {\n\n                            Swap(storage, pos, pos * 2 + 2);\n                            pos = pos * 2 + 2;\n                        }\n                    }\n                    else break;\n                }\n            return t;\n        }\n\n        public void Clear()\n        {\n            storage.Clear();\n        }\n        /// <summary>\n        /// \u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b1\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b7 \u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080 \u00c3\u00a2\u00e2\u0082\u00ac\u00e2\u0084\u00a2\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b4\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b0\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bb\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b5\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00bd\u00c3\u0083\u00c6\u0092\u00c3\u0082\u00c2\u0090\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u00b8\u00c3\u0083\u00c6\u0092\u00c3\u00a2\u00e2\u0082\u00ac\u00cb\u009c\u00c3\u0083\u00e2\u0080\u009a\u00c3\u0082\u00c2\u008f\n        /// </summary>\n        /// <returns></returns>\n        public T Peek()\n        {\n            return storage[0];\n        }\n        public int Count\n        {\n            get { return storage.Count; }\n        }\n        //void RemoveLast, Size, peeklast, add\n    }\n    static void Swap<T>(ref T lhs, ref T rhs)\n    {\n        T temp;\n        temp = lhs;\n        lhs = rhs;\n        rhs = temp;\n    }\n    static void Swap<T>(T[] a, int l, int r)\n    {\n        T temp;\n        temp = a[l];\n        a[l] = a[r];\n        a[r] = temp;\n    }\n    static void Swap<T>(List<T> a, int l, int r)\n    {\n        T temp;\n        temp = a[l];\n        a[l] = a[r];\n        a[r] = temp;\n    }\n\n    bool outregion(long y, long x, long n, long m)\n    {\n        if (x < 0 || x >= m || y < 0 || y >= n)\n            return true;\n        return false;\n    }\n    static void initlist<T>(ref List<T>[] list, int n)\n    {\n        list = new List<T>[n];\n        for (int i = 0; i < n; i++)\n            list[i] = new List<T>();\n    }\n    static void newarray<T>(ref T[][] array, int n, int m)\n    {\n        array = new T[n][];\n        for (int i = 0; i < n; i++)\n            array[i] = new T[m];\n    }\n    static void newarray<T>(ref T[] array, int n)\n    {\n        array = new T[n];\n    }\n    static void fill<T>(T[] array, T value)\n    {\n        for (int i = 0; i < array.Length; i++)\n            array[i] = value;\n    }\n    static void fill<T>(T[][] array, T value)\n    {\n        for (int i = 0; i < array.Length; i++)\n            for (int j = 0; j < array[i].Length; j++)\n                array[i][j] = value;\n    }\n    public bool NextPermutation<T>(T[] b, Comparison<T> ic)\n    {\n        for (int j = b.Length - 2; j >= 0; j--)\n        {\n            if (ic(b[j], b[j + 1]) < 0)\n            {\n                for (int l = b.Length - 1; l >= 0; l--)\n                {\n                    if (ic(b[l], b[j]) > 0)\n                    {\n                        Swap(b, j, l);\n                        Array.Reverse(b, j + 1, b.Length - (j + 1));\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    int[,] step8 = new int[,]\n    {\n        {-1,0 },\n        {1,0 },\n        {0,-1 },\n        {0,1 },\n        {1,1 },\n        {-1,1 },\n        {-1,-1 },\n        {1,-1 },\n    };\n    int[,] step4 = new int[,]\n    {\n        {-1,0 },\n        {1,0 },\n        {0,-1 },\n        {0,1 },\n    };\n    struct Vector2\n    {\n        public double x;\n        public double y;\n        public Vector2(double x, double y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n        public double Dist(Vector2 to)\n        {\n            return Math.Sqrt(Math.Abs(Math.Pow(to.x - x, 2)) + Math.Abs(Math.Pow(to.y - y, 2)));\n        }\n        public static bool operator ==(Vector2 left, Vector2 right) { return left.x == right.x && left.y == right.y; }\n        public static bool operator !=(Vector2 left, Vector2 right) { return left.x != right.x || left.y != right.y; }\n    }\n    #endregion\n    #endregion\n\n}\n",
        "prob_desc_input_spec": "The first line contains the positive integer n (1\u2009\u2264\u2009n\u2009\u2264\u2009106)\u00a0\u2014 the number of pixels display should have.",
        "src_uid": "f52af273954798a4ae38a1378bfbf77a",
        "bug_code_uid": "5f4a01d128e72b4e659a33f3b1613e0c",
        "equal_cnt": 4,
        "prob_desc_time_limit": "1 second",
        "similarity_score": 0.9880743026733398,
        "bug_exec_outcome": "WRONG_ANSWER",
        "lang_cluster": "C#",
        "potential_dominant_fix_op": "replace",
        "prob_desc_sample_inputs": [
            "8",
            "64",
            "5",
            "999999"
        ],
        "prob_desc_input_from": "standard input",
        "prob_desc_description": "A big company decided to launch a new series of rectangular displays, and decided that the display must have exactly n pixels. Your task is to determine the size of the rectangular display \u2014 the number of lines (rows) of pixels a and the number of columns of pixels b, so that:  there are exactly n pixels on the display;  the number of rows does not exceed the number of columns, it means a\u2009\u2264\u2009b;  the difference b\u2009-\u2009a is as small as possible. ",
        "lang": "MS C#",
        "fix_exec_outcome": "",
        "insert_cnt": 1,
        "fix_source_code": "",
        "prob_desc_notes": "NoteIn the first example the minimum possible difference equals 2, so on the display should be 2 rows of 4 pixels.In the second example the minimum possible difference equals 0, so on the display should be 8 rows of 8 pixels.In the third example the minimum possible difference equals 4, so on the display should be 1 row of 5 pixels.",
        "file_name": "C#.jsonl",
        "tags": [
            "math",
            "brute force"
        ],
        "prob_desc_output_to": "standard output",
        "prob_desc_created_at": "1482113100",
        "prob_desc_memory_limit": "256 megabytes",
        "prob_desc_sample_outputs": [
            "2 4",
            "8 8",
            "1 5",
            "999 1001"
        ],
        "hidden_unit_tests": "[{\"input\": \"8\\r\\n\", \"output\": [\"2 4\"]}, {\"input\": \"64\\r\\n\", \"output\": [\"8 8\"]}, {\"input\": \"5\\r\\n\", \"output\": [\"1 5\"]}, {\"input\": \"999999\\r\\n\", \"output\": [\"999 1001\"]}, {\"input\": \"716539\\r\\n\", \"output\": [\"97 7387\"]}, {\"input\": \"1\\r\\n\", \"output\": [\"1 1\"]}, {\"input\": \"2\\r\\n\", \"output\": [\"1 2\"]}, {\"input\": \"3\\r\\n\", \"output\": [\"1 3\"]}, {\"input\": \"4\\r\\n\", \"output\": [\"2 2\"]}, {\"input\": \"6\\r\\n\", \"output\": [\"2 3\"]}, {\"input\": \"7\\r\\n\", \"output\": [\"1 7\"]}, {\"input\": \"9\\r\\n\", \"output\": [\"3 3\"]}, {\"input\": \"10\\r\\n\", \"output\": [\"2 5\"]}, {\"input\": \"11\\r\\n\", \"output\": [\"1 11\"]}, {\"input\": \"12\\r\\n\", \"output\": [\"3 4\"]}, {\"input\": \"15\\r\\n\", \"output\": [\"3 5\"]}, {\"input\": \"100\\r\\n\", \"output\": [\"10 10\"]}, {\"input\": \"101\\r\\n\", \"output\": [\"1 101\"]}, {\"input\": \"169\\r\\n\", \"output\": [\"13 13\"]}, {\"input\": \"179\\r\\n\", \"output\": [\"1 179\"]}, {\"input\": \"190\\r\\n\", \"output\": [\"10 19\"]}, {\"input\": \"1000\\r\\n\", \"output\": [\"25 40\"]}, {\"input\": \"10000\\r\\n\", \"output\": [\"100 100\"]}, {\"input\": \"10001\\r\\n\", \"output\": [\"73 137\"]}, {\"input\": \"100000\\r\\n\", \"output\": [\"250 400\"]}, {\"input\": \"100001\\r\\n\", \"output\": [\"11 9091\"]}, {\"input\": \"1000000\\r\\n\", \"output\": [\"1000 1000\"]}, {\"input\": \"999983\\r\\n\", \"output\": [\"1 999983\"]}, {\"input\": \"524288\\r\\n\", \"output\": [\"512 1024\"]}, {\"input\": \"954493\\r\\n\", \"output\": [\"971 983\"]}, {\"input\": \"966289\\r\\n\", \"output\": [\"983 983\"]}, {\"input\": \"944663\\r\\n\", \"output\": [\"961 983\"]}, {\"input\": \"912673\\r\\n\", \"output\": [\"97 9409\"]}, {\"input\": \"732641\\r\\n\", \"output\": [\"679 1079\"]}, {\"input\": \"232897\\r\\n\", \"output\": [\"343 679\"]}, {\"input\": \"16807\\r\\n\", \"output\": [\"49 343\"]}, {\"input\": \"999958\\r\\n\", \"output\": [\"2 499979\"]}, {\"input\": \"990151\\r\\n\", \"output\": [\"1 990151\"]}, {\"input\": \"997002\\r\\n\", \"output\": [\"998 999\"]}, {\"input\": \"20\\r\\n\", \"output\": [\"4 5\"]}, {\"input\": \"20261\\r\\n\", \"output\": [\"1 20261\"]}, {\"input\": \"999123\\r\\n\", \"output\": [\"3 333041\"]}, {\"input\": \"901841\\r\\n\", \"output\": [\"1 901841\"]}]"
    }
}