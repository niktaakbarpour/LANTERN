{
    "oai_response": {
        "choices": [
            {
                "message": {
                    "role": "assistant",
                    "content": "```C#\nusing System;\nusing System.IO;\n\nclass Program\n{\n    static void Main()\n    {\n        string input = Console.ReadLine();\n        string[] numbers = input.Split(' ');\n        int a = int.Parse(numbers[0]);\n        int b = int.Parse(numbers[1]);\n\n        int maxDifferentShades = Math.Min(a, b);\n        int maxSameShades = (Math.Max(a, b) - maxDifferentShades) / 2;\n\n        Console.WriteLine(maxDifferentShades + \" \" + maxSameShades);\n    }\n}\n```"
                }
            }
        ],
        "prompt": [
            "Fix a buggy program written in C# language to solve the following programming problem:\nDescription: One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Can you help him?\nInput Specification: The single line of the input contains two positive integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of red and blue socks that Vasya's got.\nOutput Specification: Print two space-separated integers \u2014 the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got. Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.\n\nSample Input:\n3 1\nSample Output:\n1 1\n\nSample Input:\n2 3\nSample Output:\n2 0\n\nSample Input:\n7 3\nSample Output:\n3 2\n\nNotes: NoteIn the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.\nTake input from standard input and output to standard output\n\nHere is the code with a bug of COMPILATION_ERROR:\n\nusing System;\nusing System.IO;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Reflection;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Linq;\n\n#region testlib\npublic delegate ReadDelegate<T> ReadDelegate<T>(out T value);\npublic delegate bool ParserDelegate<T>(string word, out T item);\n\npublic class Input : IDisposable\n{\n    private static EventArgs DefaultEventArgs = new EventArgs();\n\n    public TextReader TextReader { get; private set; }\n\n    public event EventHandler OnEndOfStream;\n    public event EventHandler OnParseError;\n    public event EventHandler OnReadError;\n\n    public bool CanRead { get; private set; }\n    public bool ThrowExceptions { get; set; }\n\n    string line = string.Empty;\n    int pos = 0;\n\n    static EventHandler emptyHandler;\n\n    public Input(string path)\n        : this(File.OpenRead(path))\n    {\n    }\n    public Input(Stream s)\n        : this(new StreamReader(s))\n    {\n\n    }\n    public Input(TextReader tr)\n    {\n        TextReader = tr;\n\n        if (emptyHandler == null)\n            emptyHandler = (a, b) => { };\n\n        OnEndOfStream = emptyHandler;\n        OnParseError = emptyHandler;\n        OnReadError = emptyHandler;\n\n        CanRead = true;\n    }\n\n    public static implicit operator Input(Stream s)\n    {\n        return new Input(s);\n    }\n    public static implicit operator Input(TextReader tr)\n    {\n        return new Input(tr);\n    }\n\n    private bool ReadStream()\n    {\n        if (!CanRead) return false;\n        if (pos < line.Length) return true;\n\n        Clear();\n\n        string s = TextReader.ReadLine();\n        if (s == null)\n        {\n            CanRead = false;\n            return false;\n        }\n\n        line = s;\n        return true;\n    }\n\n    public ReadDelegate<T> r<T>(out T value)\n    {\n        value = ReadData<T>();\n        return r;\n    }\n\n    public void SkipChar()\n    {\n        if (pos < line.Length) pos++;\n        else\n        {\n            ReadStream();\n        }\n    }\n    public void SkipChars(int length)\n    {\n        while (length > 0)\n        {\n            int dt = line.Length - pos;\n            if (dt <= 0)\n            {\n                length--;\n                if (!ReadStream()) return;\n            }\n            dt = Math.Min(length, dt);\n            pos += dt;\n            length -= dt;\n        }\n    }\n\n    public void SkipWhiteSpace()\n    {\n        while (true)\n        {\n            for (; pos < line.Length; pos++)\n            {\n                if (!char.IsWhiteSpace(line[pos])) return;\n            }\n            if (!ReadStream())\n            {\n                OnEndOfStream(this, DefaultEventArgs);\n                return;\n            }\n        }\n    }\n    public bool CanReadData()\n    {\n        SkipWhiteSpace();\n        return CanRead;\n    }\n\n    public T[] ReadArray<T>()\n    {\n        int length = ReadInt32();\n        return ReadArray<T>(length);\n    }\n    public T[] ReadArray<T>(int length)\n    {\n        ParserDelegate<T> parser = Parser.GetPrimitiveParser<T>();\n        return ReadArray<T>(length, parser);\n    }\n    public T[] ReadArray<T>(ParserDelegate<T> parser)\n    {\n        int length = ReadInt32();\n        return ReadArray<T>(length, parser);\n    }\n    public T[] ReadArray<T>(int length, ParserDelegate<T> parser)\n    {\n        T[] res = new T[length];\n        for (int i = 0; i < length; i++)\n        {\n            res[i] = ReadData<T>(parser);\n        }\n        return res;\n    }\n\n    public Decimal ReadDecimal()\n    {\n        return ReadData<Decimal>(Parser.DecimalParser);\n    }\n    public Double ReadDouble()\n    {\n        return ReadData<Double>(Parser.DoubleParser);\n    }\n    public Single ReadSingle()\n    {\n        return ReadData<Single>(Parser.SingleParser);\n    }\n    public UInt64 ReadUInt64()\n    {\n        return ReadData<UInt64>(UInt64.TryParse);\n    }\n    public UInt32 ReadUInt32()\n    {\n        return ReadData<UInt32>(UInt32.TryParse);\n    }\n    public UInt16 ReadUInt16()\n    {\n        return ReadData<UInt16>(UInt16.TryParse);\n    }\n    public Int64 ReadInt64()\n    {\n        return ReadData<Int64>(Int64.TryParse);\n    }\n    public Int32 ReadInt32()\n    {\n        return ReadData<Int32>(Int32.TryParse);\n    }\n    public Int16 ReadInt16()\n    {\n        return ReadData<Int16>(Int16.TryParse);\n    }\n    public Boolean ReadYesNo()\n    {\n        return ReadData<Boolean>(Parser.YesNoParser);\n    }\n    public Boolean ReadBoolean()\n    {\n        return ReadData<Boolean>(Boolean.TryParse);\n    }\n    public Byte ReadByte()\n    {\n        return ReadData<Byte>(Byte.TryParse);\n    }\n\n    private bool ReadCheck()\n    {\n        if (!CanRead)\n        {\n            OnReadError(this, DefaultEventArgs);\n            if (ThrowExceptions)\n            {\n                throw new Exception(\"!CanRead\");\n            }\n            return false;\n        }\n        return true;\n    }\n    public T ReadData<T>()\n    {\n        return ReadData<T>(true);\n    }\n    public T ReadData<T>(bool skipWhiteSpace)\n    {\n        ParserDelegate<T> parser = Parser.GetPrimitiveParser<T>();\n        return ReadData<T>(parser, skipWhiteSpace);\n    }\n    public T ReadData<T>(ParserDelegate<T> parser)\n    {\n        return ReadData<T>(parser, true);\n    }\n    public T ReadData<T>(ParserDelegate<T> parser, bool skipWhiteSpace)\n    {\n        if (skipWhiteSpace)\n            SkipWhiteSpace();\n\n        if (!ReadCheck()) return default(T);\n\n        string s = ReadWord(false);\n\n        T res;\n        if (!parser.Invoke(s, out res))\n        {\n            OnParseError(this, DefaultEventArgs);\n            if (ThrowExceptions)\n            {\n                throw new Exception(\"!validate, word = \" + Output.ToString(s, 256));\n            }\n        }\n        return res;\n    }\n\n    public string ReadWord()\n    {\n        return ReadWord(true);\n    }\n    public string ReadWord(bool skipWhiteSpace)\n    {\n        if (skipWhiteSpace)\n            SkipWhiteSpace();\n\n        if (!ReadCheck()) return string.Empty;\n\n        int from = pos;\n        int to = pos;\n        for (int i = pos; i < line.Length; i++)\n        {\n            if (char.IsWhiteSpace(line[i])) break;\n            to = i + 1;\n        }\n        pos = to;\n\n        return line.Substring(from, to - from);\n    }\n\n    public string ReadLine()\n    {\n        if (!ReadCheck()) return string.Empty;\n\n        ReadStream();\n        string res = line.Substring(pos);\n        pos = line.Length;\n\n        return res;\n    }\n\n    public void Close()\n    {\n        TextReader.Close();\n    }\n    public void Clear()\n    {\n        pos = 0;\n        line = string.Empty;\n    }\n\n    private bool disposed = false;\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!this.disposed)\n        {\n            if (disposing)\n            {\n                line = string.Empty;\n                TextReader.Dispose();\n            }\n            disposed = true;\n        }\n    }\n    ~Input()\n    {\n        Dispose(false);\n    }\n}\npublic class Output : IDisposable\n{\n    static char[] space = new char[] { ' ' };\n\n    public TextWriter TextWriter { get; private set; }\n    public bool AutoFlush { get; set; }\n\n\n    public static string ToString(object obj, int maxLength)\n    {\n        return ToString(FormatReal(obj), maxLength);\n    }\n    public static string ToString(string s, int maxLength)\n    {\n        if (s.Length <= maxLength) return s;\n        else return s.Substring(0, maxLength) + \"...\";\n    }\n    public static object FormatReal(object v, string format)\n    {\n        if (v is decimal) return ((decimal)v).ToString(format).Replace(',', '.');\n        if (v is double) return ((double)v).ToString(format).Replace(',', '.');\n        if (v is float) return ((float)v).ToString(format).Replace(',', '.');\n\n        return v;\n    }\n    public static object FormatReal(object v)\n    {\n        if (v is decimal || v is double || v is float)\n        {\n            return v.ToString().Replace(',', '.');\n        }\n        return v;\n    }\n\n    public Output()\n        : this(new MemoryStream())\n    {\n    }\n    public Output(string path)\n        : this(File.Create(path))\n    {\n\n    }\n    public Output(Stream s)\n        : this(new StreamWriter(s))\n    {\n    }\n    public Output(TextWriter tw)\n    {\n        TextWriter = tw;\n    }\n\n    public static implicit operator Output(Stream s)\n    {\n        return new Output(s);\n    }\n\n    public static implicit operator Output(TextWriter tw)\n    {\n        return new Output(tw);\n    }\n\n    public static Output operator +(Output output, object obj)\n    {\n        output.Write(obj);\n        return output;\n    }\n    public Output WriteArray<T>(params T[] array)\n    {\n        return WriteArray<T>(array, false);\n    }\n    public Output WriteArray<T>(T[] array, bool appendLength)\n    {\n        return WriteArray<T>(array, 0, array.Length, appendLength);\n    }\n    public Output WriteArray<T>(T[] array, int index, int count)\n    {\n        return WriteArray<T>(array, index, count, false);\n    }\n    public Output WriteArray<T>(T[] array, int index, int count, bool appendLength)\n    {\n        if (index + count > array.Length)\n        {\n            string message = string.Format(\n                \"Index out of range: {0} + {1} >= {2}\",\n                index,\n                count,\n                array.Length);\n            throw new Exception(message);\n        }\n        if (appendLength)\n        {\n            WriteLine(count);\n        }\n        for (int i = 0; i < count; i++)\n        {\n            Write(array[i]);\n            Write(space, 0, space.Length);\n        }\n        WriteLine();\n\n        return this;\n    }\n    public Output WriteLine(object obj)\n    {\n        obj = FormatReal(obj);\n        return WriteLine(obj.ToString());\n    }\n    public Output WriteLine(string format, params object[] args)\n    {\n        return WriteLine(string.Format(format, args));\n    }\n    public Output WriteLine(string s)\n    {\n        return WriteLine(s.ToCharArray());\n    }\n    public Output WriteLine(char[] buffer)\n    {\n        return WriteLine(buffer, 0, buffer.Length);\n    }\n    public Output WriteLine(char[] buffer, int index, int count)\n    {\n        TextWriter.WriteLine(buffer, index, count);\n        if (AutoFlush) TextWriter.Flush();\n        return this;\n    }\n    public Output WriteLine()\n    {\n        TextWriter.WriteLine();\n        if (AutoFlush) TextWriter.Flush();\n        return this;\n    }\n    public Output Write(object obj)\n    {\n        obj = FormatReal(obj);\n        return Write(obj.ToString());\n    }\n    public Output Write(string format, params object[] args)\n    {\n        return Write(string.Format(format, args));\n    }\n    public Output Write(string s)\n    {\n        return Write(s.ToCharArray());\n    }\n    public Output Write(char[] buffer)\n    {\n        return Write(buffer, 0, buffer.Length);\n    }\n    public Output Write(char[] buffer, int index, int count)\n    {\n        TextWriter.Write(buffer, index, count);\n        if (AutoFlush) TextWriter.Flush();\n        return this;\n    }\n\n    public void Close()\n    {\n        TextWriter.Close();\n    }\n    public void Flush()\n    {\n        TextWriter.Flush();\n    }\n\n\n    private bool disposed = false;\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!this.disposed)\n        {\n            if (disposing)\n            {\n                TextWriter.Dispose();\n            }\n            disposed = true;\n        }\n    }\n    ~Output()\n    {\n        Dispose(false);\n    }\n}\npublic static class Parser\n{\n    public static ParserDelegate<T> GetPrimitiveParser<T>()\n    {\n        if (!typeof(T).IsPrimitive) throw new Exception(\"Unknown type\");\n        else if (default(T) is Byte) return new ParserDelegate<Byte>(Byte.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Boolean) return new ParserDelegate<Boolean>(Boolean.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Int16) return new ParserDelegate<Int16>(Int16.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Int32) return new ParserDelegate<Int32>(Int32.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Int64) return new ParserDelegate<Int64>(Int64.TryParse) as ParserDelegate<T>;\n        else if (default(T) is UInt16) return new ParserDelegate<UInt16>(UInt16.TryParse) as ParserDelegate<T>;\n        else if (default(T) is UInt32) return new ParserDelegate<UInt32>(UInt32.TryParse) as ParserDelegate<T>;\n        else if (default(T) is UInt64) return new ParserDelegate<UInt64>(UInt64.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Single) return new ParserDelegate<Single>(Parser.SingleParser) as ParserDelegate<T>;\n        else if (default(T) is Double) return new ParserDelegate<Double>(Parser.DoubleParser) as ParserDelegate<T>;\n        else if (default(T) is Decimal) return new ParserDelegate<Decimal>(Parser.DecimalParser) as ParserDelegate<T>;\n        else if (default(T) is String) return new ParserDelegate<String>(Parser.StringParser) as ParserDelegate<T>;\n        else throw new Exception(\"Unknown type\");\n    }\n    public static bool YesNoParser(string s, out Boolean result)\n    {\n        s = s.ToLower();\n        if (s == \"yes\") result = true;\n        else if (s == \"no\") result = false;\n        else\n        {\n            result = false;\n            return false;\n        }\n        return true;\n    }\n    public static bool StringParser(string s, out string result)\n    {\n        result = s;\n        return string.IsNullOrEmpty(s);\n    }\n    public static bool DecimalParser(string s, out Decimal result)\n    {\n        return Decimal.TryParse(s.Replace('.', ','), out result);\n    }\n    public static bool DoubleParser(string s, out Double result)\n    {\n        return Double.TryParse(s.Replace('.', ','), out result);\n    }\n    public static bool SingleParser(string s, out Single result)\n    {\n        return Single.TryParse(s.Replace('.', ','), out result);\n    }\n}\n#endregion\nstatic class Program\n{\n    #region Streams\n    static string endl = Environment.NewLine;\n    static Input cin = new Input(Console.In);\n    static Output cout = new Output(Console.Out);\n    static Output cerr = new Output(Console.Error);\n\n    static void InitIO()\n    {\n#if !DEBUG\n        cin = new Input(\"input.txt\");\n        cout = new Output(\"output.txt\");\n#endif\n    }\n    #endregion\n    #region Time\n    static Stopwatch sw = new Stopwatch();\n    static void Start()\n    {\n        sw.Reset();\n        sw.Start();\n    }\n    static void Restart(string text = \"\")\n    {\n        Stop(text);\n        Start();\n    }\n    static void Time(string text = \"\")\n    {\n        if (string.IsNullOrEmpty(text))\n        {\n            cerr.WriteLine(sw.Elapsed);\n        }\n        else\n        {\n            cerr.WriteLine(text + \": \" + sw.Elapsed);\n        }\n    }\n    static void Stop(string text = \"\")\n    {\n        sw.Stop();\n        Time(text);\n    }\n    //*/\n    #endregion\n    const string nyan = \"^_^\";\n    static void Solve()\n    {\n        var a = cin.ReadInt32();\n        var b = cin.ReadInt32();\n\n        cout.WriteLine(\"{0} {1}\", Math.Min(a, b), (Math.Max(a, b) - Math.Min(a, b) / 2);\n    }\n\n    static string[] Tests =\n    {\n        @\"3 1 2\n1 1 1\",\n        @\"4 2 3\n1 2 4 8\",\n        @\"3 1 2\n17 18 4\"\n    };\n\n    static string Generate(int n, int t, int seed)\n    {\n        var rnd = new Random(seed);\n        var a = new int[n];\n        for (var i = 0; i < n; i++)\n        {\n            a[i] = rnd.Next(1, 101);\n        }\n\n        var sb = new StringWriter();\n        var output = new Output(sb);\n\n        output.WriteLine(\"{0} {1}\", n, t);\n        output.WriteArray(a, false);\n\n        return sb.ToString();\n    }\n    static void Main()\n    {\n#if DEBUG\n        if (Tests.Length == 0)\n        {\n            Solve();\n        }\n        else\n        {\n            foreach(var test in Tests)\n            {\n                cin = new Input(new StringReader(test));\n                Solve();\n            }\n            /*\n            for (var i = 0; i < 100; i++)\n            {\n                var test = Generate(100, 10000000, i);\n                Start();\n                cin = new Input(new StringReader(test));\n                Solve();\n                Stop();\n            }\n            //*/\n        }\n\n#else\n        Solve();\n#endif\n    }\n}\n\nProvide the fixed C# code without any description or extra tokens.\n\nFixed source code:",
            ""
        ]
    },
    "source_data": {
        "delete_cnt": 1,
        "fix_code_uid": "",
        "difficulty": 800,
        "replace_cnt": 0,
        "fix_ops_cnt": 2,
        "prob_desc_output_spec": "Print two space-separated integers \u2014 the maximum number of days when Vasya can wear different socks and the number of days when he can wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got. Keep in mind that at the end of the day Vasya throws away the socks that he's been wearing on that day.",
        "apr_id": "8cb727381f420d2dc0ce98702a4b0cc4",
        "bug_source_code": "using System;\nusing System.IO;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Reflection;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Linq;\n\n#region testlib\npublic delegate ReadDelegate<T> ReadDelegate<T>(out T value);\npublic delegate bool ParserDelegate<T>(string word, out T item);\n\npublic class Input : IDisposable\n{\n    private static EventArgs DefaultEventArgs = new EventArgs();\n\n    public TextReader TextReader { get; private set; }\n\n    public event EventHandler OnEndOfStream;\n    public event EventHandler OnParseError;\n    public event EventHandler OnReadError;\n\n    public bool CanRead { get; private set; }\n    public bool ThrowExceptions { get; set; }\n\n    string line = string.Empty;\n    int pos = 0;\n\n    static EventHandler emptyHandler;\n\n    public Input(string path)\n        : this(File.OpenRead(path))\n    {\n    }\n    public Input(Stream s)\n        : this(new StreamReader(s))\n    {\n\n    }\n    public Input(TextReader tr)\n    {\n        TextReader = tr;\n\n        if (emptyHandler == null)\n            emptyHandler = (a, b) => { };\n\n        OnEndOfStream = emptyHandler;\n        OnParseError = emptyHandler;\n        OnReadError = emptyHandler;\n\n        CanRead = true;\n    }\n\n    public static implicit operator Input(Stream s)\n    {\n        return new Input(s);\n    }\n    public static implicit operator Input(TextReader tr)\n    {\n        return new Input(tr);\n    }\n\n    private bool ReadStream()\n    {\n        if (!CanRead) return false;\n        if (pos < line.Length) return true;\n\n        Clear();\n\n        string s = TextReader.ReadLine();\n        if (s == null)\n        {\n            CanRead = false;\n            return false;\n        }\n\n        line = s;\n        return true;\n    }\n\n    public ReadDelegate<T> r<T>(out T value)\n    {\n        value = ReadData<T>();\n        return r;\n    }\n\n    public void SkipChar()\n    {\n        if (pos < line.Length) pos++;\n        else\n        {\n            ReadStream();\n        }\n    }\n    public void SkipChars(int length)\n    {\n        while (length > 0)\n        {\n            int dt = line.Length - pos;\n            if (dt <= 0)\n            {\n                length--;\n                if (!ReadStream()) return;\n            }\n            dt = Math.Min(length, dt);\n            pos += dt;\n            length -= dt;\n        }\n    }\n\n    public void SkipWhiteSpace()\n    {\n        while (true)\n        {\n            for (; pos < line.Length; pos++)\n            {\n                if (!char.IsWhiteSpace(line[pos])) return;\n            }\n            if (!ReadStream())\n            {\n                OnEndOfStream(this, DefaultEventArgs);\n                return;\n            }\n        }\n    }\n    public bool CanReadData()\n    {\n        SkipWhiteSpace();\n        return CanRead;\n    }\n\n    public T[] ReadArray<T>()\n    {\n        int length = ReadInt32();\n        return ReadArray<T>(length);\n    }\n    public T[] ReadArray<T>(int length)\n    {\n        ParserDelegate<T> parser = Parser.GetPrimitiveParser<T>();\n        return ReadArray<T>(length, parser);\n    }\n    public T[] ReadArray<T>(ParserDelegate<T> parser)\n    {\n        int length = ReadInt32();\n        return ReadArray<T>(length, parser);\n    }\n    public T[] ReadArray<T>(int length, ParserDelegate<T> parser)\n    {\n        T[] res = new T[length];\n        for (int i = 0; i < length; i++)\n        {\n            res[i] = ReadData<T>(parser);\n        }\n        return res;\n    }\n\n    public Decimal ReadDecimal()\n    {\n        return ReadData<Decimal>(Parser.DecimalParser);\n    }\n    public Double ReadDouble()\n    {\n        return ReadData<Double>(Parser.DoubleParser);\n    }\n    public Single ReadSingle()\n    {\n        return ReadData<Single>(Parser.SingleParser);\n    }\n    public UInt64 ReadUInt64()\n    {\n        return ReadData<UInt64>(UInt64.TryParse);\n    }\n    public UInt32 ReadUInt32()\n    {\n        return ReadData<UInt32>(UInt32.TryParse);\n    }\n    public UInt16 ReadUInt16()\n    {\n        return ReadData<UInt16>(UInt16.TryParse);\n    }\n    public Int64 ReadInt64()\n    {\n        return ReadData<Int64>(Int64.TryParse);\n    }\n    public Int32 ReadInt32()\n    {\n        return ReadData<Int32>(Int32.TryParse);\n    }\n    public Int16 ReadInt16()\n    {\n        return ReadData<Int16>(Int16.TryParse);\n    }\n    public Boolean ReadYesNo()\n    {\n        return ReadData<Boolean>(Parser.YesNoParser);\n    }\n    public Boolean ReadBoolean()\n    {\n        return ReadData<Boolean>(Boolean.TryParse);\n    }\n    public Byte ReadByte()\n    {\n        return ReadData<Byte>(Byte.TryParse);\n    }\n\n    private bool ReadCheck()\n    {\n        if (!CanRead)\n        {\n            OnReadError(this, DefaultEventArgs);\n            if (ThrowExceptions)\n            {\n                throw new Exception(\"!CanRead\");\n            }\n            return false;\n        }\n        return true;\n    }\n    public T ReadData<T>()\n    {\n        return ReadData<T>(true);\n    }\n    public T ReadData<T>(bool skipWhiteSpace)\n    {\n        ParserDelegate<T> parser = Parser.GetPrimitiveParser<T>();\n        return ReadData<T>(parser, skipWhiteSpace);\n    }\n    public T ReadData<T>(ParserDelegate<T> parser)\n    {\n        return ReadData<T>(parser, true);\n    }\n    public T ReadData<T>(ParserDelegate<T> parser, bool skipWhiteSpace)\n    {\n        if (skipWhiteSpace)\n            SkipWhiteSpace();\n\n        if (!ReadCheck()) return default(T);\n\n        string s = ReadWord(false);\n\n        T res;\n        if (!parser.Invoke(s, out res))\n        {\n            OnParseError(this, DefaultEventArgs);\n            if (ThrowExceptions)\n            {\n                throw new Exception(\"!validate, word = \" + Output.ToString(s, 256));\n            }\n        }\n        return res;\n    }\n\n    public string ReadWord()\n    {\n        return ReadWord(true);\n    }\n    public string ReadWord(bool skipWhiteSpace)\n    {\n        if (skipWhiteSpace)\n            SkipWhiteSpace();\n\n        if (!ReadCheck()) return string.Empty;\n\n        int from = pos;\n        int to = pos;\n        for (int i = pos; i < line.Length; i++)\n        {\n            if (char.IsWhiteSpace(line[i])) break;\n            to = i + 1;\n        }\n        pos = to;\n\n        return line.Substring(from, to - from);\n    }\n\n    public string ReadLine()\n    {\n        if (!ReadCheck()) return string.Empty;\n\n        ReadStream();\n        string res = line.Substring(pos);\n        pos = line.Length;\n\n        return res;\n    }\n\n    public void Close()\n    {\n        TextReader.Close();\n    }\n    public void Clear()\n    {\n        pos = 0;\n        line = string.Empty;\n    }\n\n    private bool disposed = false;\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!this.disposed)\n        {\n            if (disposing)\n            {\n                line = string.Empty;\n                TextReader.Dispose();\n            }\n            disposed = true;\n        }\n    }\n    ~Input()\n    {\n        Dispose(false);\n    }\n}\npublic class Output : IDisposable\n{\n    static char[] space = new char[] { ' ' };\n\n    public TextWriter TextWriter { get; private set; }\n    public bool AutoFlush { get; set; }\n\n\n    public static string ToString(object obj, int maxLength)\n    {\n        return ToString(FormatReal(obj), maxLength);\n    }\n    public static string ToString(string s, int maxLength)\n    {\n        if (s.Length <= maxLength) return s;\n        else return s.Substring(0, maxLength) + \"...\";\n    }\n    public static object FormatReal(object v, string format)\n    {\n        if (v is decimal) return ((decimal)v).ToString(format).Replace(',', '.');\n        if (v is double) return ((double)v).ToString(format).Replace(',', '.');\n        if (v is float) return ((float)v).ToString(format).Replace(',', '.');\n\n        return v;\n    }\n    public static object FormatReal(object v)\n    {\n        if (v is decimal || v is double || v is float)\n        {\n            return v.ToString().Replace(',', '.');\n        }\n        return v;\n    }\n\n    public Output()\n        : this(new MemoryStream())\n    {\n    }\n    public Output(string path)\n        : this(File.Create(path))\n    {\n\n    }\n    public Output(Stream s)\n        : this(new StreamWriter(s))\n    {\n    }\n    public Output(TextWriter tw)\n    {\n        TextWriter = tw;\n    }\n\n    public static implicit operator Output(Stream s)\n    {\n        return new Output(s);\n    }\n\n    public static implicit operator Output(TextWriter tw)\n    {\n        return new Output(tw);\n    }\n\n    public static Output operator +(Output output, object obj)\n    {\n        output.Write(obj);\n        return output;\n    }\n    public Output WriteArray<T>(params T[] array)\n    {\n        return WriteArray<T>(array, false);\n    }\n    public Output WriteArray<T>(T[] array, bool appendLength)\n    {\n        return WriteArray<T>(array, 0, array.Length, appendLength);\n    }\n    public Output WriteArray<T>(T[] array, int index, int count)\n    {\n        return WriteArray<T>(array, index, count, false);\n    }\n    public Output WriteArray<T>(T[] array, int index, int count, bool appendLength)\n    {\n        if (index + count > array.Length)\n        {\n            string message = string.Format(\n                \"Index out of range: {0} + {1} >= {2}\",\n                index,\n                count,\n                array.Length);\n            throw new Exception(message);\n        }\n        if (appendLength)\n        {\n            WriteLine(count);\n        }\n        for (int i = 0; i < count; i++)\n        {\n            Write(array[i]);\n            Write(space, 0, space.Length);\n        }\n        WriteLine();\n\n        return this;\n    }\n    public Output WriteLine(object obj)\n    {\n        obj = FormatReal(obj);\n        return WriteLine(obj.ToString());\n    }\n    public Output WriteLine(string format, params object[] args)\n    {\n        return WriteLine(string.Format(format, args));\n    }\n    public Output WriteLine(string s)\n    {\n        return WriteLine(s.ToCharArray());\n    }\n    public Output WriteLine(char[] buffer)\n    {\n        return WriteLine(buffer, 0, buffer.Length);\n    }\n    public Output WriteLine(char[] buffer, int index, int count)\n    {\n        TextWriter.WriteLine(buffer, index, count);\n        if (AutoFlush) TextWriter.Flush();\n        return this;\n    }\n    public Output WriteLine()\n    {\n        TextWriter.WriteLine();\n        if (AutoFlush) TextWriter.Flush();\n        return this;\n    }\n    public Output Write(object obj)\n    {\n        obj = FormatReal(obj);\n        return Write(obj.ToString());\n    }\n    public Output Write(string format, params object[] args)\n    {\n        return Write(string.Format(format, args));\n    }\n    public Output Write(string s)\n    {\n        return Write(s.ToCharArray());\n    }\n    public Output Write(char[] buffer)\n    {\n        return Write(buffer, 0, buffer.Length);\n    }\n    public Output Write(char[] buffer, int index, int count)\n    {\n        TextWriter.Write(buffer, index, count);\n        if (AutoFlush) TextWriter.Flush();\n        return this;\n    }\n\n    public void Close()\n    {\n        TextWriter.Close();\n    }\n    public void Flush()\n    {\n        TextWriter.Flush();\n    }\n\n\n    private bool disposed = false;\n    public void Dispose()\n    {\n        Dispose(true);\n        GC.SuppressFinalize(this);\n    }\n\n    protected virtual void Dispose(bool disposing)\n    {\n        if (!this.disposed)\n        {\n            if (disposing)\n            {\n                TextWriter.Dispose();\n            }\n            disposed = true;\n        }\n    }\n    ~Output()\n    {\n        Dispose(false);\n    }\n}\npublic static class Parser\n{\n    public static ParserDelegate<T> GetPrimitiveParser<T>()\n    {\n        if (!typeof(T).IsPrimitive) throw new Exception(\"Unknown type\");\n        else if (default(T) is Byte) return new ParserDelegate<Byte>(Byte.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Boolean) return new ParserDelegate<Boolean>(Boolean.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Int16) return new ParserDelegate<Int16>(Int16.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Int32) return new ParserDelegate<Int32>(Int32.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Int64) return new ParserDelegate<Int64>(Int64.TryParse) as ParserDelegate<T>;\n        else if (default(T) is UInt16) return new ParserDelegate<UInt16>(UInt16.TryParse) as ParserDelegate<T>;\n        else if (default(T) is UInt32) return new ParserDelegate<UInt32>(UInt32.TryParse) as ParserDelegate<T>;\n        else if (default(T) is UInt64) return new ParserDelegate<UInt64>(UInt64.TryParse) as ParserDelegate<T>;\n        else if (default(T) is Single) return new ParserDelegate<Single>(Parser.SingleParser) as ParserDelegate<T>;\n        else if (default(T) is Double) return new ParserDelegate<Double>(Parser.DoubleParser) as ParserDelegate<T>;\n        else if (default(T) is Decimal) return new ParserDelegate<Decimal>(Parser.DecimalParser) as ParserDelegate<T>;\n        else if (default(T) is String) return new ParserDelegate<String>(Parser.StringParser) as ParserDelegate<T>;\n        else throw new Exception(\"Unknown type\");\n    }\n    public static bool YesNoParser(string s, out Boolean result)\n    {\n        s = s.ToLower();\n        if (s == \"yes\") result = true;\n        else if (s == \"no\") result = false;\n        else\n        {\n            result = false;\n            return false;\n        }\n        return true;\n    }\n    public static bool StringParser(string s, out string result)\n    {\n        result = s;\n        return string.IsNullOrEmpty(s);\n    }\n    public static bool DecimalParser(string s, out Decimal result)\n    {\n        return Decimal.TryParse(s.Replace('.', ','), out result);\n    }\n    public static bool DoubleParser(string s, out Double result)\n    {\n        return Double.TryParse(s.Replace('.', ','), out result);\n    }\n    public static bool SingleParser(string s, out Single result)\n    {\n        return Single.TryParse(s.Replace('.', ','), out result);\n    }\n}\n#endregion\nstatic class Program\n{\n    #region Streams\n    static string endl = Environment.NewLine;\n    static Input cin = new Input(Console.In);\n    static Output cout = new Output(Console.Out);\n    static Output cerr = new Output(Console.Error);\n\n    static void InitIO()\n    {\n#if !DEBUG\n        cin = new Input(\"input.txt\");\n        cout = new Output(\"output.txt\");\n#endif\n    }\n    #endregion\n    #region Time\n    static Stopwatch sw = new Stopwatch();\n    static void Start()\n    {\n        sw.Reset();\n        sw.Start();\n    }\n    static void Restart(string text = \"\")\n    {\n        Stop(text);\n        Start();\n    }\n    static void Time(string text = \"\")\n    {\n        if (string.IsNullOrEmpty(text))\n        {\n            cerr.WriteLine(sw.Elapsed);\n        }\n        else\n        {\n            cerr.WriteLine(text + \": \" + sw.Elapsed);\n        }\n    }\n    static void Stop(string text = \"\")\n    {\n        sw.Stop();\n        Time(text);\n    }\n    //*/\n    #endregion\n    const string nyan = \"^_^\";\n    static void Solve()\n    {\n        var a = cin.ReadInt32();\n        var b = cin.ReadInt32();\n\n        cout.WriteLine(\"{0} {1}\", Math.Min(a, b), (Math.Max(a, b) - Math.Min(a, b) / 2);\n    }\n\n    static string[] Tests =\n    {\n        @\"3 1 2\n1 1 1\",\n        @\"4 2 3\n1 2 4 8\",\n        @\"3 1 2\n17 18 4\"\n    };\n\n    static string Generate(int n, int t, int seed)\n    {\n        var rnd = new Random(seed);\n        var a = new int[n];\n        for (var i = 0; i < n; i++)\n        {\n            a[i] = rnd.Next(1, 101);\n        }\n\n        var sb = new StringWriter();\n        var output = new Output(sb);\n\n        output.WriteLine(\"{0} {1}\", n, t);\n        output.WriteArray(a, false);\n\n        return sb.ToString();\n    }\n    static void Main()\n    {\n#if DEBUG\n        if (Tests.Length == 0)\n        {\n            Solve();\n        }\n        else\n        {\n            foreach(var test in Tests)\n            {\n                cin = new Input(new StringReader(test));\n                Solve();\n            }\n            /*\n            for (var i = 0; i < 100; i++)\n            {\n                var test = Generate(100, 10000000, i);\n                Start();\n                cin = new Input(new StringReader(test));\n                Solve();\n                Stop();\n            }\n            //*/\n        }\n\n#else\n        Solve();\n#endif\n    }\n}",
        "prob_desc_input_spec": "The single line of the input contains two positive integers a and b (1\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009100) \u2014 the number of red and blue socks that Vasya's got.",
        "src_uid": "775766790e91e539c1cfaa5030e5b955",
        "bug_code_uid": "8fc0139870f2e7e024f41f0d97e07489",
        "equal_cnt": 3,
        "prob_desc_time_limit": "1 second",
        "similarity_score": 0.9981387257575989,
        "bug_exec_outcome": "COMPILATION_ERROR",
        "lang_cluster": "C#",
        "potential_dominant_fix_op": "delete",
        "prob_desc_sample_inputs": [
            "3 1",
            "2 3",
            "7 3"
        ],
        "prob_desc_input_from": "standard input",
        "prob_desc_description": "One day Vasya the Hipster decided to count how many socks he had. It turned out that he had a red socks and b blue socks.According to the latest fashion, hipsters should wear the socks of different colors: a red one on the left foot, a blue one on the right foot.Every day Vasya puts on new socks in the morning and throws them away before going to bed as he doesn't want to wash them.Vasya wonders, what is the maximum number of days when he can dress fashionable and wear different socks, and after that, for how many days he can then wear the same socks until he either runs out of socks or cannot make a single pair from the socks he's got.Can you help him?",
        "lang": "MS C#",
        "fix_exec_outcome": "",
        "insert_cnt": 1,
        "fix_source_code": "",
        "prob_desc_notes": "NoteIn the first sample Vasya can first put on one pair of different socks, after that he has two red socks left to wear on the second day.",
        "file_name": "C#.jsonl",
        "tags": [
            "math",
            "implementation"
        ],
        "prob_desc_output_to": "standard output",
        "prob_desc_created_at": "1443430800",
        "prob_desc_memory_limit": "256 megabytes",
        "prob_desc_sample_outputs": [
            "1 1",
            "2 0",
            "3 2"
        ],
        "hidden_unit_tests": "[{\"input\": \"3 1\\r\\n\", \"output\": [\"1 1\", \"1  1\", \"1\\r\\n1\"]}, {\"input\": \"2 3\\r\\n\", \"output\": [\"2  0\", \"2 0\", \"2\\r\\n0\"]}, {\"input\": \"7 3\\r\\n\", \"output\": [\"3\\r\\n2\", \"3  2\", \"3 2\"]}, {\"input\": \"100 100\\r\\n\", \"output\": [\"100 0\", \"100  0\", \"100\\r\\n0\"]}, {\"input\": \"4 10\\r\\n\", \"output\": [\"4\\r\\n3\", \"4  3\", \"4 3\"]}, {\"input\": \"6 10\\r\\n\", \"output\": [\"6\\r\\n2\", \"6 2\", \"6  2\"]}, {\"input\": \"6 11\\r\\n\", \"output\": [\"6\\r\\n2\", \"6 2\", \"6  2\"]}, {\"input\": \"10 40\\r\\n\", \"output\": [\"10\\r\\n15\", \"10 15\", \"10  15\"]}, {\"input\": \"11 56\\r\\n\", \"output\": [\"11 22\", \"11\\r\\n22\", \"11  22\"]}, {\"input\": \"34 30\\r\\n\", \"output\": [\"30\\r\\n2\", \"30 2\", \"30  2\"]}, {\"input\": \"33 33\\r\\n\", \"output\": [\"33  0\", \"33\\r\\n0\", \"33 0\"]}, {\"input\": \"100 45\\r\\n\", \"output\": [\"45\\r\\n27\", \"45  27\", \"45 27\"]}, {\"input\": \"100 23\\r\\n\", \"output\": [\"23  38\", \"23\\r\\n38\", \"23 38\"]}, {\"input\": \"45 12\\r\\n\", \"output\": [\"12  16\", \"12 16\", \"12\\r\\n16\"]}, {\"input\": \"1 1\\r\\n\", \"output\": [\"1  0\", \"1\\r\\n0\", \"1 0\"]}, {\"input\": \"1 100\\r\\n\", \"output\": [\"1  49\", \"1 49\", \"1\\r\\n49\"]}, {\"input\": \"100 1\\r\\n\", \"output\": [\"1  49\", \"1 49\", \"1\\r\\n49\"]}, {\"input\": \"68 59\\r\\n\", \"output\": [\"59  4\", \"59\\r\\n4\", \"59 4\"]}, {\"input\": \"45 99\\r\\n\", \"output\": [\"45\\r\\n27\", \"45  27\", \"45 27\"]}, {\"input\": \"99 100\\r\\n\", \"output\": [\"99  0\", \"99 0\", \"99\\r\\n0\"]}, {\"input\": \"100 98\\r\\n\", \"output\": [\"98 1\", \"98\\r\\n1\", \"98  1\"]}, {\"input\": \"59 12\\r\\n\", \"output\": [\"12 23\", \"12  23\", \"12\\r\\n23\"]}, {\"input\": \"86 4\\r\\n\", \"output\": [\"4  41\", \"4\\r\\n41\", \"4 41\"]}, {\"input\": \"68 21\\r\\n\", \"output\": [\"21 23\", \"21  23\", \"21\\r\\n23\"]}, {\"input\": \"100 11\\r\\n\", \"output\": [\"11  44\", \"11\\r\\n44\", \"11 44\"]}, {\"input\": \"100 10\\r\\n\", \"output\": [\"10 45\", \"10\\r\\n45\", \"10  45\"]}, {\"input\": \"15 45\\r\\n\", \"output\": [\"15\\r\\n15\", \"15  15\", \"15 15\"]}, {\"input\": \"11 32\\r\\n\", \"output\": [\"11\\r\\n10\", \"11 10\", \"11  10\"]}, {\"input\": \"34 96\\r\\n\", \"output\": [\"34\\r\\n31\", \"34  31\", \"34 31\"]}, {\"input\": \"89 89\\r\\n\", \"output\": [\"89  0\", \"89 0\", \"89\\r\\n0\"]}]"
    }
}