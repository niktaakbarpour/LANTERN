{
    "oai_response": null,
    "source_data": {
        "delete_cnt": 3,
        "fix_code_uid": "",
        "difficulty": 1700,
        "replace_cnt": 17,
        "fix_ops_cnt": 21,
        "prob_desc_output_spec": "Output one integer which denotes the maximum number of dominoes which Anadi can place on the edges of the graph.",
        "apr_id": "e86ce886c8c69747138fd2c78092cc56",
        "bug_source_code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing static System.Math;\nusing System.Text;\nusing System.Threading;\nnamespace Program\n{\n    public static class CODEFORCES1\n    {\n        static public int numberOfRandomCases = 0;\n        static public void MakeTestCase(List<string> _input, List<string> _output, ref Func<string[], bool> _outputChecker)\n        {\n        }\n        static public void Solve()\n        {\n            var n = NN;\n            var m = NN;\n            var ab = Repeat(0, m).Select(_ => new { a = NN - 1, b = NN - 1 }).ToArray();\n            var path = Repeat(0, n).Select(_ => new List<long>()).ToArray();\n            foreach (var item in ab)\n            {\n                path[item.a].Add(item.b);\n                path[item.b].Add(item.a);\n            }\n            var edgeCount = path.Select(e => e.Count).ToArray();\n            var domino = new bool[6, 6];\n            for (var i = 0; i < 6; i++)\n            {\n                for (var j = i; j < 6; j++)\n                {\n                    domino[i, j] = true;\n                    domino[j, i] = true;\n                }\n            }\n            var ans = 0L;\n            var done = new bool[n, n];\n            var vtxNumber = new long[n];\n            foreach (var vtx in edgeCount.Select((e, i) => new { e, i }).OrderByDescending(e => e.e).Select(e => e.i))\n            {\n                foreach (var item in ab.Where(e => e.a == vtx || e.b == vtx).OrderByDescending(e =>\n                {\n                    if (e.a == vtx) return edgeCount[e.b];\n                    else return edgeCount[e.a];\n                }))\n                {\n                    if (done[item.a, item.b]) continue;\n                    done[item.a, item.b] = true;\n                    done[item.b, item.a] = true;\n                    var aidx = item.a;\n                    var bidx = item.b;\n                    if (bidx == vtx)\n                    {\n                        var t = aidx; aidx = bidx; bidx = t;\n\n                    }\n                    var a = edgeCount[aidx];\n                    var b = edgeCount[bidx];\n                    var found = false;\n                    {// find\n                        for (var i = 1; i < 7; i++)\n                        {\n                            for (var j = 1; j < 7; j++)\n                            {\n                                if (domino[i - 1, j - 1])\n                                {\n                                    if ((vtxNumber[aidx] == 0 || vtxNumber[aidx] == i) &&\n                                        (vtxNumber[bidx] == 0 || vtxNumber[bidx] == j))\n                                    {\n                                        vtxNumber[aidx] = i;\n                                        vtxNumber[bidx] = j;\n                                        domino[i - 1, j - 1] = false;\n                                        domino[j - 1, i - 1] = false;\n                                        found = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (found) break;\n                        }\n                    }\n                    if (found) ++ans;\n                }\n            }\n            Console.WriteLine(ans);\n        }\n        static public void Main(string[] args) { if (args.Length == 0) { var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw); } var t = new Thread(Solve, 134217728); t.Start(); t.Join(); Console.Out.Flush(); }\n        static class Console_\n        {\n            static Queue<string> param = new Queue<string>();\n            public static string NextString() { if (param.Count == 0) foreach (var item in Console.ReadLine().Split(' ')) param.Enqueue(item); return param.Dequeue(); }\n        }\n        static long NN => long.Parse(Console_.NextString());\n        static double ND => double.Parse(Console_.NextString());\n        static string NS => Console_.NextString();\n        static long[] NNList(long N) => Repeat(0, N).Select(_ => NN).ToArray();\n        static double[] NDList(long N) => Repeat(0, N).Select(_ => ND).ToArray();\n        static string[] NSList(long N) => Repeat(0, N).Select(_ => NS).ToArray();\n        static IEnumerable<T> OrderByRand<T>(this IEnumerable<T> x) => x.OrderBy(_ => xorshift);\n        static IEnumerable<T> Repeat<T>(T v, long n) => Enumerable.Repeat<T>(v, (int)n);\n        static IEnumerable<int> Range(long s, long c) => Enumerable.Range((int)s, (int)c);\n        static void RevSort<T>(T[] l) where T : IComparable { Array.Sort(l, (x, y) => y.CompareTo(x)); }\n        static void RevSort<T>(T[] l, Comparison<T> comp) where T : IComparable { Array.Sort(l, (x, y) => comp(y, x)); }\n        static IEnumerable<long> Primes(long x) { if (x < 2) yield break; yield return 2; var halfx = x / 2; var table = new bool[halfx + 1]; var max = (long)(Math.Sqrt(x) / 2); for (long i = 1; i <= max; ++i) { if (table[i]) continue; var add = 2 * i + 1; yield return add; for (long j = 2 * i * (i + 1); j <= halfx; j += add) table[j] = true; } for (long i = max + 1; i <= halfx; ++i) if (!table[i] && 2 * i + 1 <= x) yield return 2 * i + 1; }\n        static IEnumerable<long> Factors(long x) { if (x < 2) yield break; while (x % 2 == 0) { x /= 2; yield return 2; } var max = (long)Math.Sqrt(x); for (long i = 3; i <= max; i += 2) while (x % i == 0) { x /= i; yield return i; } if (x != 1) yield return x; }\n        static IEnumerable<long> Divisor(long x) { if (x < 1) yield break; var max = (long)Math.Sqrt(x); for (long i = 1; i <= max; ++i) { if (x % i != 0) continue; yield return i; if (i != x / i) yield return x / i; } }\n        static uint xorshift { get { _xsi.MoveNext(); return _xsi.Current; } }\n        static IEnumerator<uint> _xsi = _xsc();\n        static IEnumerator<uint> _xsc() { uint x = 123456789, y = 362436069, z = 521288629, w = (uint)(DateTime.Now.Ticks & 0xffffffff); while (true) { var t = x ^ (x << 11); x = y; y = z; z = w; w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)); yield return w; } }\n        static long GCD(long a, long b) { while (b > 0) { var tmp = b; b = a % b; a = tmp; } return a; }\n        static long LCM(long a, long b) => a * b / GCD(a, b);\n        static Mat<T> Pow<T>(Mat<T> x, long y) => Mat<T>.Pow(x, y);\n        static Mod Pow(Mod x, long y) { Mod a = 1; while (y != 0) { if ((y & 1) == 1) a.Mul(x); x.Mul(x); y >>= 1; } return a; }\n        static long Pow(long x, long y) { long a = 1; while (y != 0) { if ((y & 1) == 1) a *= x; x *= x; y >>= 1; } return a; }\n        static List<long> _fact = new List<long>() { 1 };\n        static void _B(long n) { if (n >= _fact.Count) for (int i = _fact.Count; i <= n; ++i) _fact.Add(_fact[i - 1] * i); }\n        static long Comb(long n, long k) { _B(n); if (n == 0 && k == 0) return 1; if (n < k || n < 0) return 0; return _fact[(int)n] / _fact[(int)(n - k)] / _fact[(int)k]; }\n        static long Perm(long n, long k) { _B(n); if (n == 0 && k == 0) return 1; if (n < k || n < 0) return 0; return _fact[(int)n] / _fact[(int)(n - k)]; }\n        static Func<TR> Lambda<TR>(Func<Func<TR>, TR> f) { Func<TR> t = () => default(TR); return t = () => f(t); }\n        static Func<T1, TR> Lambda<T1, TR>(Func<T1, Func<T1, TR>, TR> f) { Func<T1, TR> t = x1 => default(TR); return t = x1 => f(x1, t); }\n        static Func<T1, T2, TR> Lambda<T1, T2, TR>(Func<T1, T2, Func<T1, T2, TR>, TR> f) { Func<T1, T2, TR> t = (x1, x2) => default(TR); return t = (x1, x2) => f(x1, x2, t); }\n        static Func<T1, T2, T3, TR> Lambda<T1, T2, T3, TR>(Func<T1, T2, T3, Func<T1, T2, T3, TR>, TR> f) { Func<T1, T2, T3, TR> t = (x1, x2, x3) => default(TR); return t = (x1, x2, x3) => f(x1, x2, x3, t); }\n        static Func<T1, T2, T3, T4, TR> Lambda<T1, T2, T3, T4, TR>(Func<T1, T2, T3, T4, Func<T1, T2, T3, T4, TR>, TR> f) { Func<T1, T2, T3, T4, TR> t = (x1, x2, x3, x4) => default(TR); return t = (x1, x2, x3, x4) => f(x1, x2, x3, x4, t); }\n        static List<T> LCS<T>(T[] s, T[] t) where T : IEquatable<T> { int sl = s.Length, tl = t.Length; var dp = new int[sl + 1, tl + 1]; for (var i = 0; i < sl; i++) for (var j = 0; j < tl; j++) dp[i + 1, j + 1] = s[i].Equals(t[j]) ? dp[i, j] + 1 : Max(dp[i + 1, j], dp[i, j + 1]); { var r = new List<T>(); int i = sl, j = tl; while (i > 0 && j > 0) if (s[--i].Equals(t[--j])) r.Add(s[i]); else if (dp[i, j + 1] > dp[i + 1, j]) ++j; else ++i; r.Reverse(); return r; } }\n        static long LIS<T>(T[] array, bool strict) { var l = new List<T>(); foreach (var e in array) { var i = l.BinarySearch(e); if (i < 0) i = ~i; else if (!strict) ++i; if (i == l.Count) l.Add(e); else l[i] = e; } return l.Count; }\n        class PQ<T> where T : IComparable\n        {\n            List<T> h; Comparison<T> c; public T Peek => h[0]; public int Count => h.Count;\n            public PQ(int cap, Comparison<T> c, bool asc = true) { h = new List<T>(cap); this.c = asc ? c : (x, y) => c(y, x); }\n            public PQ(Comparison<T> c, bool asc = true) { h = new List<T>(); this.c = asc ? c : (x, y) => c(y, x); }\n            public PQ(int cap, bool asc = true) : this(cap, (x, y) => x.CompareTo(y), asc) { }\n            public PQ(bool asc = true) : this((x, y) => x.CompareTo(y), asc) { }\n            public void Push(T v) { var i = h.Count; h.Add(v); while (i > 0) { var ni = (i - 1) / 2; if (c(v, h[ni]) >= 0) break; h[i] = h[ni]; i = ni; } h[i] = v; }\n            public T Pop() { var r = h[0]; var v = h[h.Count - 1]; h.RemoveAt(h.Count - 1); if (h.Count == 0) return r; var i = 0; while (i * 2 + 1 < h.Count) { var i1 = i * 2 + 1; var i2 = i * 2 + 2; if (i2 < h.Count && c(h[i1], h[i2]) > 0) i1 = i2; if (c(v, h[i1]) <= 0) break; h[i] = h[i1]; i = i1; } h[i] = v; return r; }\n        }\n        class PQ<TK, TV> where TK : IComparable\n        {\n            PQ<Tuple<TK, TV>> q; public Tuple<TK, TV> Peek => q.Peek; public int Count => q.Count;\n            public PQ(int cap, Comparison<TK> c, bool asc = true) { q = new PQ<Tuple<TK, TV>>(cap, (x, y) => c(x.Item1, y.Item1), asc); }\n            public PQ(Comparison<TK> c, bool asc = true) { q = new PQ<Tuple<TK, TV>>((x, y) => c(x.Item1, y.Item1), asc); }\n            public PQ(int cap, bool asc = true) : this(cap, (x, y) => x.CompareTo(y), asc) { }\n            public PQ(bool asc = true) : this((x, y) => x.CompareTo(y), asc) { }\n            public void Push(TK k, TV v) => q.Push(Tuple.Create(k, v));\n            public Tuple<TK, TV> Pop() => q.Pop();\n        }\n        public class UF\n        {\n            long[] d;\n            public UF(long s) { d = Repeat(-1L, s).ToArray(); }\n            public bool Unite(long x, long y) { x = Root(x); y = Root(y); if (x != y) { if (d[y] < d[x]) { var t = y; y = x; x = t; } d[x] += d[y]; d[y] = x; } return x != y; }\n            public bool IsSame(long x, long y) => Root(x) == Root(y);\n            public long Root(long x) => d[x] < 0 ? x : d[x] = Root(d[x]);\n            public long Count(long x) => -d[Root(x)];\n        }\n        struct Mod : IEquatable<Mod>, IEquatable<long>\n        {\n            static public long _mod = 1000000007; long v;\n            public Mod(long x) { if (x < _mod && x >= 0) v = x; else if ((v = x % _mod) < 0) v += _mod; }\n            static public implicit operator Mod(long x) => new Mod(x);\n            static public implicit operator long(Mod x) => x.v;\n            public void Add(Mod x) { if ((v += x.v) >= _mod) v -= _mod; }\n            public void Sub(Mod x) { if ((v -= x.v) < 0) v += _mod; }\n            public void Mul(Mod x) => v = (v * x.v) % _mod;\n            public void Div(Mod x) => v = (v * Inverse(x.v)) % _mod;\n            static public Mod operator +(Mod x, Mod y) { var t = x.v + y.v; return t >= _mod ? new Mod { v = t - _mod } : new Mod { v = t }; }\n            static public Mod operator -(Mod x, Mod y) { var t = x.v - y.v; return t < 0 ? new Mod { v = t + _mod } : new Mod { v = t }; }\n            static public Mod operator *(Mod x, Mod y) => x.v * y.v;\n            static public Mod operator /(Mod x, Mod y) => x.v * Inverse(y.v);\n            static public bool operator ==(Mod x, Mod y) => x.v == y.v;\n            static public bool operator !=(Mod x, Mod y) => x.v != y.v;\n            static public long Inverse(long x) { long b = _mod, r = 1, u = 0, t = 0; while (b > 0) { var q = x / b; t = u; u = r - q * u; r = t; t = b; b = x - q * b; x = t; } return r < 0 ? r + _mod : r; }\n            public bool Equals(Mod x) => v == x.v;\n            public bool Equals(long x) => v == x;\n            public override bool Equals(object x) => x == null ? false : Equals((Mod)x);\n            public override int GetHashCode() => v.GetHashCode();\n            public override string ToString() => v.ToString();\n            static List<Mod> _fact = new List<Mod>() { 1 };\n            static void B(long n) { if (n >= _fact.Count) for (int i = _fact.Count; i <= n; ++i) _fact.Add(_fact[i - 1] * i); }\n            static public Mod Comb(long n, long k) { B(n); if (n == 0 && k == 0) return 1; if (n < k || n < 0) return 0; return _fact[(int)n] / _fact[(int)(n - k)] / _fact[(int)k]; }\n            static public Mod Perm(long n, long k) { B(n); if (n == 0 && k == 0) return 1; if (n < k || n < 0) return 0; return _fact[(int)n] / _fact[(int)(n - k)]; }\n        }\n        struct Mat<T>\n        {\n            T[,] m;\n            public Mat(T[,] v) { m = (T[,])v.Clone(); }\n            static public implicit operator Mat<T>(T[,] v) => new Mat<T>(v);\n            public T this[int r, int c] { get { return m[r, c]; } set { m[r, c] = value; } }\n            static public Mat<T> operator +(Mat<T> a, T x) { var tm = (T[,])a.m.Clone(); for (int r = 0; r < tm.GetLength(0); ++r) for (int c = 0; c < tm.GetLength(1); ++c) tm[r, c] += (dynamic)x; return tm; }\n            static public Mat<T> operator +(Mat<T> a, Mat<T> b) { var tm = (T[,])a.m.Clone(); for (int r = 0; r < tm.GetLength(0); ++r) for (int c = 0; c < tm.GetLength(1); ++c) tm[r, c] += (dynamic)b[r, c]; return tm; }\n            static public Mat<T> operator -(Mat<T> a, T x) { var tm = (T[,])a.m.Clone(); for (int r = 0; r < tm.GetLength(0); ++r) for (int c = 0; c < tm.GetLength(1); ++c) tm[r, c] -= (dynamic)x; return tm; }\n            static public Mat<T> operator -(Mat<T> a, Mat<T> b) { var tm = (T[,])a.m.Clone(); for (int r = 0; r < tm.GetLength(0); ++r) for (int c = 0; c < tm.GetLength(1); ++c) tm[r, c] -= (dynamic)b[r, c]; return tm; }\n            static public Mat<T> operator *(Mat<T> a, T x) { var tm = (T[,])a.m.Clone(); for (int r = 0; r < tm.GetLength(0); ++r) for (int c = 0; c < tm.GetLength(1); ++c) tm[r, c] *= (dynamic)x; return tm; }\n            static public Mat<T> operator *(Mat<T> a, Mat<T> b) { var nr = a.m.GetLength(0); var nc = b.m.GetLength(1); var tm = new T[nr, nc]; for (int i = 0; i < nr; ++i) for (int j = 0; j < nc; ++j) tm[i, j] = (dynamic)0; for (int r = 0; r < nr; ++r) for (int c = 0; c < nc; ++c) for (int i = 0; i < a.m.GetLength(1); ++i) tm[r, c] += a[r, i] * (dynamic)b[i, c]; return tm; }\n            static public Mat<T> Pow(Mat<T> x, long y) { var n = x.m.GetLength(0); var t = (Mat<T>)new T[n, n]; for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) t[i, j] = (dynamic)(i == j ? 1 : 0); while (y != 0) { if ((y & 1) == 1) t *= x; x *= x; y >>= 1; } return t; }\n        }\n        class Tree\n        {\n            long N; int l; List<long>[] p; int[] d; long[][] pr; long r; Tuple<long, long, int>[] e; Tuple<long, long>[] b; bool lca; bool euler; bool bfs;\n            public Tree(List<long>[] p_, long r_) { N = p_.Length; p = p_; r = r_; lca = false; euler = false; }\n            public Tuple<long, long>[] BFSRoot() { if (!bfs) { var nb = new List<Tuple<long, long>>(); var q = new Queue<long>(); var d = new bool[N]; nb.Add(Tuple.Create(r, -1L)); d[r] = true; q.Enqueue(r); while (q.Count > 0) { var w = q.Dequeue(); foreach (var i in p[w]) { if (d[i]) continue; d[i] = true; q.Enqueue(i); nb.Add(Tuple.Create(i, w)); } } b = nb.ToArray(); bfs = true; } return b; }\n            public Tuple<long, long>[] BFSLeaf() => BFSRoot().Reverse().ToArray();\n            public Tuple<long, long, int>[] Euler() { if (!euler) { var ne = new List<Tuple<long, long, int>>(); var s = new Stack<Tuple<long, long>>(); var d = new bool[N]; d[r] = true; s.Push(Tuple.Create(r, -1L)); while (s.Count > 0) { var w = s.Peek(); var ad = true; foreach (var i in p[w.Item1]) { if (d[i]) continue; d[i] = true; ad = false; s.Push(Tuple.Create(i, w.Item1)); } if (!ad || p[w.Item1].Count == 1) ne.Add(Tuple.Create(w.Item1, w.Item2, 1)); if (ad) { s.Pop(); ne.Add(Tuple.Create(w.Item1, w.Item2, -1)); } } e = ne.ToArray(); euler = true; } return e; }\n            public long LCA(long u, long v) { if (!lca) { l = 0; while (N > (1 << l)) l++; d = new int[N]; pr = Repeat(0, l).Select(_ => new long[N]).ToArray(); d[r] = 0; pr[0][r] = -1; var q = new Stack<long>(); q.Push(r); while (q.Count > 0) { var w = q.Pop(); foreach (var i in p[w]) { if (i == pr[0][w]) continue; q.Push(i); d[i] = d[w] + 1; pr[0][i] = w; } } for (var k = 0; k + 1 < l; k++) for (var w = 0; w < N; w++) if (pr[k][w] < 0) pr[k + 1][w] = -1; else pr[k + 1][w] = pr[k][pr[k][w]]; lca = true; } if (d[u] > d[v]) { var t = u; u = v; v = t; } for (var k = 0; k < l; k++) if ((((d[v] - d[u]) >> k) & 1) != 0) v = pr[k][v]; if (u == v) return u; for (var k = l - 1; k >= 0; k--) if (pr[k][u] != pr[k][v]) { u = pr[k][u]; v = pr[k][v]; } return pr[0][u]; }\n        }\n        class Graph\n        {\n            int n; List<Tuple<int, int, long>> pathList; Dictionary<int, long>[] vtxPath; long INF = (long.MaxValue >> 1) - 1;\n            public Graph(long _n)\n            {\n                n = (int)_n;\n                pathList = new List<Tuple<int, int, long>>();\n                vtxPath = Repeat(0, n).Select(_ => new Dictionary<int, long>()).ToArray();\n            }\n            public void AddPath(long a, long b, long c)\n            {\n                pathList.Add(Tuple.Create((int)a, (int)b, c));\n                vtxPath[a][(int)b] = vtxPath[a].ContainsKey((int)b) ? Min(vtxPath[a][(int)b], c) : c;\n            }\n            public long[,] WarshallFloyd()\n            {\n                var ret = new long[n, n];\n                for (var i = 0; i < n; i++)\n                    for (var j = 0; j < n; j++)\n                        ret[i, j] = vtxPath[i].ContainsKey(j) ? vtxPath[i][j] : INF;\n                for (var k = 0; k < n; k++)\n                    for (var i = 0; i < n; i++)\n                        for (var j = 0; j < n; j++)\n                            ret[i, j] = Min(ret[i, j], ret[i, k] + ret[k, j]);\n                return ret;\n            }\n            public Tuple<long[], int?[], bool[]> BellmanFord(long s)\n            {\n                var dist = Repeat(INF, n).ToArray();\n                var pred = new int?[n];\n                var neg = new bool[n];\n                dist[s] = 0;\n                for (var i = 1; i < n; i++)\n                    foreach (var path in pathList)\n                        if (dist[path.Item2] > (dist[path.Item1] == INF ? INF : dist[path.Item1] + path.Item3))\n                        {\n                            dist[path.Item2] = dist[path.Item1] + path.Item3;\n                            pred[path.Item2] = path.Item1;\n                        }\n                for (var i = 0; i < n; i++)\n                    foreach (var path in pathList)\n                        if (dist[path.Item2] > (dist[path.Item1] == INF ? INF : dist[path.Item1] + path.Item3) || neg[path.Item1])\n                        {\n                            dist[path.Item2] = dist[path.Item1] + path.Item3;\n                            neg[path.Item2] = true;\n                        }\n                return Tuple.Create(dist, pred, neg);\n            }\n            public Tuple<long[], int?[]> Dijkstra(long s)\n            {\n                var dist = Repeat(long.MaxValue >> 2, n).ToArray();\n                var pred = new int?[n];\n                dist[s] = 0;\n                var q = new PQ<long, int>();\n                q.Push(0, (int)s);\n                while (q.Count > 0)\n                {\n                    var u = q.Pop().Item2;\n                    foreach (var path in vtxPath[u])\n                    {\n                        var v = path.Key;\n                        var alt = dist[u] + path.Value;\n                        if (dist[v] > alt)\n                        {\n                            dist[v] = alt;\n                            pred[v] = u;\n                            q.Push(alt, v);\n                        }\n                    }\n                }\n                return Tuple.Create(dist, pred);\n            }\n        }\n        class BT<T> where T : IComparable\n        {\n            class Node { public Node l; public Node r; public T v; public bool b; public int c; }\n            Comparison<T> c; Node r; bool ch; T lm;\n            public BT(Comparison<T> _c) { c = _c; }\n            public BT() : this((x, y) => x.CompareTo(y)) { }\n            bool R(Node n) => n != null && !n.b;\n            bool B(Node n) => n != null && n.b;\n            long C(Node n) => n?.c ?? 0;\n            Node RtL(Node n) { Node m = n.r, t = m.l; m.l = n; n.r = t; n.c -= m.c - (t?.c ?? 0); m.c += n.c - (t?.c ?? 0); return m; }\n            Node RtR(Node n) { Node m = n.l, t = m.r; m.r = n; n.l = t; n.c -= m.c - (t?.c ?? 0); m.c += n.c - (t?.c ?? 0); return m; }\n            Node RtLR(Node n) { n.l = RtL(n.l); return RtR(n); }\n            Node RtRL(Node n) { n.r = RtR(n.r); return RtL(n); }\n            public void Add(T x) { r = A(r, x); r.b = true; }\n            Node A(Node n, T x) { if (n == null) { ch = true; return new Node() { v = x, c = 1 }; } if (c(x, n.v) < 0) n.l = A(n.l, x); else n.r = A(n.r, x); n.c++; return Bl(n); }\n            Node Bl(Node n) { if (!ch) return n; if (!B(n)) return n; if (R(n.l) && R(n.l.l)) { n = RtR(n); n.l.b = true; } else if (R(n.l) && R(n.l.r)) { n = RtLR(n); n.l.b = true; } else if (R(n.r) && R(n.r.l)) { n = RtRL(n); n.r.b = true; } else if (R(n.r) && R(n.r.r)) { n = RtL(n); n.r.b = true; } else ch = false; return n; }\n            public void Remove(T x) { r = Rm(r, x); if (r != null) r.b = true; }\n            Node Rm(Node n, T x) { if (n == null) { ch = false; return n; } n.c--; var r = c(x, n.v); if (r < 0) { n.l = Rm(n.l, x); return BlL(n); } if (r > 0) { n.r = Rm(n.r, x); return BlR(n); } if (n.l == null) { ch = n.b; return n.r; } n.l = RmM(n.l); n.v = lm; return BlL(n); }\n            Node RmM(Node n) { n.c--; if (n.r != null) { n.r = RmM(n.r); return BlR(n); } lm = n.v; ch = n.b; return n.l; }\n            Node BlL(Node n) { if (!ch) return n; if (B(n.r) && R(n.r.l)) { var b = n.b; n = RtRL(n); n.b = b; n.l.b = true; ch = false; } else if (B(n.r) && R(n.r.r)) { var b = n.b; n = RtL(n); n.b = b; n.r.b = true; n.l.b = true; ch = false; } else if (B(n.r)) { ch = n.b; n.b = true; n.r.b = false; } else { n = RtL(n); n.b = true; n.l.b = false; n.l = BlL(n.l); ch = false; } return n; }\n            Node BlR(Node n) { if (!ch) return n; if (B(n.l) && R(n.l.r)) { var b = n.b; n = RtLR(n); n.b = b; n.r.b = true; ch = false; } else if (B(n.l) && R(n.l.l)) { var b = n.b; n = RtR(n); n.b = b; n.l.b = true; n.r.b = true; ch = false; } else if (B(n.l)) { ch = n.b; n.b = true; n.l.b = false; } else { n = RtR(n); n.b = true; n.r.b = false; n.r = BlR(n.r); ch = false; } return n; }\n            public T this[long i] { get { return At(r, i); } }\n            T At(Node n, long i) { if (n == null) return default(T); if (n.l == null) if (i == 0) return n.v; else return At(n.r, i - 1); if (n.l.c == i) return n.v; if (n.l.c > i) return At(n.l, i); return At(n.r, i - n.l.c - 1); }\n            public bool Have(T x) { var t = FindUpper(x); return t < C(r) && At(r, t).CompareTo(x) == 0; }\n            public long FindUpper(T x, bool allowSame = true) => allowSame ? FL(r, x) + 1 : FU(r, x);\n            long FU(Node n, T x) { if (n == null) return 0; var r = c(x, n.v); if (r < 0) return FU(n.l, x); return C(n.l) + 1 + FU(n.r, x); }\n            public long FindLower(T x, bool allowSame = true) { var t = FL(r, x); if (allowSame) return t + 1 < C(r) && At(r, t + 1).CompareTo(x) == 0 ? t + 1 : t < 0 ? C(r) : t; return t < 0 ? C(r) : t; }\n            long FL(Node n, T x) { if (n == null) return -1; var r = c(x, n.v); if (r > 0) return C(n.l) + 1 + FL(n.r, x); return FL(n.l, x); }\n            public T Min() { Node n = r, p = null; while (n != null) { p = n; n = n.l; } return p == null ? default(T) : p.v; }\n            public T Max() { Node n = r, p = null; while (n != null) { p = n; n = n.r; } return p == null ? default(T) : p.v; }\n            public bool Any() => r != null;\n            public long Count() => C(r);\n            public IEnumerable<T> List() => L(r);\n            IEnumerable<T> L(Node n) { if (n == null) yield break; foreach (var i in L(n.l)) yield return i; yield return n.v; foreach (var i in L(n.r)) yield return i; }\n        }\n        class Dict<K, V> : Dictionary<K, V>\n        {\n            Func<K, V> d;\n            public Dict(Func<K, V> _d) { d = _d; }\n            public Dict() : this(_ => default(V)) { }\n            new public V this[K i] { get { V v; return TryGetValue(i, out v) ? v : base[i] = d(i); } set { base[i] = value; } }\n        }\n        class Deque<T>\n        {\n            T[] b; int o, c;\n            public int Count;\n            public T this[int i] { get { return b[gi(i)]; } set { b[gi(i)] = value; } }\n            public Deque(int cap = 16) { b = new T[c = cap]; }\n            int gi(int i) { if (i >= c) throw new Exception(); var r = o + i; return r >= c ? r - c : r; }\n            public void PushFront(T x) { if (Count == c) e(); if (--o < 0) o += b.Length; b[o] = x; ++Count; }\n            public T PopFront() { if (Count-- == 0) throw new Exception(); var r = b[o++]; if (o >= c) o -= c; return r; }\n            public T Front => b[o];\n            public void PushBack(T x) { if (Count == c) e(); var i = o + Count++; b[i >= c ? i - c : i] = x; }\n            public T PopBack() { if (Count == 0) throw new Exception(); return b[gi(--Count)]; }\n            public T Back => b[gi(Count - 1)];\n            void e() { T[] nb = new T[c << 1]; if (o > c - Count) { var l = b.Length - o; Array.Copy(b, o, nb, 0, l); Array.Copy(b, 0, nb, l, Count - l); } else Array.Copy(b, o, nb, 0, Count); b = nb; o = 0; c <<= 1; }\n            public void Insert(int i, T x) { if (i > Count) throw new Exception(); this.PushFront(x); for (int j = 0; j < i; j++) this[j] = this[j + 1]; this[i] = x; }\n            public T RemoveAt(int i) { if (i < 0 || i >= Count) throw new Exception(); var r = this[i]; for (int j = i; j > 0; j--) this[j] = this[j - 1]; this.PopFront(); return r; }\n        }\n        class SegTree<T>\n        {\n            int n; T ti; Func<T, T, T> f; T[] dat;\n            public SegTree(long _n, T _ti, Func<T, T, T> _f) { n = 1; while (n < _n) n <<= 1; ti = _ti; f = _f; dat = Repeat(ti, n << 1).ToArray(); for (var i = n - 1; i > 0; i--) dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]); }\n            public SegTree(List<T> l, T _ti, Func<T, T, T> _f) : this(l.Count, _ti, _f) { for (var i = 0; i < l.Count; i++) dat[n + i] = l[i]; for (var i = n - 1; i > 0; i--) dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]); }\n            public void Update(long i, T v) { dat[i += n] = v; while ((i >>= 1) > 0) dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]); }\n            public T Query(long l, long r) { var vl = ti; var vr = ti; for (long li = n + l, ri = n + r; li < ri; li >>= 1, ri >>= 1) { if ((li & 1) == 1) vl = f(vl, dat[li++]); if ((ri & 1) == 1) vr = f(dat[--ri], vr); } return f(vl, vr); }\n            public T this[long idx] { get { return dat[idx + n]; } set { Update(idx, value); } }\n        }\n        class LazySegTree<T, E>\n        {\n            int n, height; T ti; E ei; Func<T, T, T> f; Func<T, E, T> g; Func<E, E, E> h; T[] dat; E[] laz;\n            public LazySegTree(long _n, T _ti, E _ei, Func<T, T, T> _f, Func<T, E, T> _g, Func<E, E, E> _h) { n = 1; height = 0; while (n < _n) { n <<= 1; ++height; } ti = _ti; ei = _ei; f = _f; g = _g; h = _h; dat = Repeat(ti, n << 1).ToArray(); laz = Repeat(ei, n << 1).ToArray(); for (var i = n - 1; i > 0; i--) dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]); }\n            public LazySegTree(List<T> l, T _ti, E _ei, Func<T, T, T> _f, Func<T, E, T> _g, Func<E, E, E> _h) : this(l.Count, _ti, _ei, _f, _g, _h) { for (var i = 0; i < l.Count; i++) dat[n + i] = l[i]; for (var i = n - 1; i > 0; i--) dat[i] = f(dat[(i << 1) | 0], dat[(i << 1) | 1]); }\n            T Reflect(long i) => laz[i].Equals(ei) ? dat[i] : g(dat[i], laz[i]);\n            void Eval(long i) { if (laz[i].Equals(ei)) return; laz[(i << 1) | 0] = h(laz[(i << 1) | 0], laz[i]); laz[(i << 1) | 1] = h(laz[(i << 1) | 1], laz[i]); dat[i] = Reflect(i); laz[i] = ei; }\n            void Thrust(long i) { for (var j = height; j > 0; j--) Eval(i >> j); }\n            void Recalc(long i) { while ((i >>= 1) > 0) dat[i] = f(Reflect((i << 1) | 0), Reflect((i << 1) | 1)); }\n            public void Update(long l, long r, E v) { Thrust(l += n); Thrust(r += n - 1); for (long li = l, ri = r + 1; li < ri; li >>= 1, ri >>= 1) { if ((li & 1) == 1) { laz[li] = h(laz[li], v); ++li; } if ((ri & 1) == 1) { --ri; laz[ri] = h(laz[ri], v); } } Recalc(l); Recalc(r); }\n            public T Query(long l, long r) { Thrust(l += n); Thrust(r += n - 1); var vl = ti; var vr = ti; for (long li = l, ri = r + 1; li < ri; li >>= 1, ri >>= 1) { if ((li & 1) == 1) vl = f(vl, Reflect(li++)); if ((ri & 1) == 1) vr = f(Reflect(--ri), vr); } return f(vl, vr); }\n            public T this[long idx] { get { Thrust(idx += n); return dat[idx] = Reflect(idx); } set { Thrust(idx += n); dat[idx] = value; laz[idx] = ei; Recalc(idx); } }\n        }\n    }\n}\n",
        "prob_desc_input_spec": "The first line contains two integers $$$n$$$ and $$$m$$$ ($$$1 \\leq n \\leq 7$$$, $$$0 \\leq m \\leq \\frac{n\\cdot(n-1)}{2}$$$) \u2014 the number of vertices and the number of edges in the graph. The next $$$m$$$ lines contain two integers each. Integers in the $$$i$$$-th line are $$$a_i$$$ and $$$b_i$$$ ($$$1 \\leq a, b \\leq n$$$, $$$a \\neq b$$$) and denote that there is an edge which connects vertices $$$a_i$$$ and $$$b_i$$$. The graph might be disconnected. It's however guaranteed that the graph doesn't contain any self-loops, and that there is at most one edge between any pair of vertices.",
        "src_uid": "11e6559cfb71b8f6ca88242094b17a2b",
        "bug_code_uid": "6234e408b4708e148a7961370affa163",
        "equal_cnt": 22,
        "prob_desc_time_limit": "2 seconds",
        "similarity_score": 0.9382774829864502,
        "bug_exec_outcome": "WRONG_ANSWER",
        "lang_cluster": "C#",
        "potential_dominant_fix_op": "replace",
        "prob_desc_sample_inputs": [
            "4 4\n1 2\n2 3\n3 4\n4 1",
            "7 0",
            "3 1\n1 3",
            "7 21\n1 2\n1 3\n1 4\n1 5\n1 6\n1 7\n2 3\n2 4\n2 5\n2 6\n2 7\n3 4\n3 5\n3 6\n3 7\n4 5\n4 6\n4 7\n5 6\n5 7\n6 7"
        ],
        "prob_desc_input_from": "standard input",
        "prob_desc_description": "Anadi has a set of dominoes. Every domino has two parts, and each part contains some dots. For every $$$a$$$ and $$$b$$$ such that $$$1 \\leq a \\leq b \\leq 6$$$, there is exactly one domino with $$$a$$$ dots on one half and $$$b$$$ dots on the other half. The set contains exactly $$$21$$$ dominoes. Here is an exact illustration of his set:  Also, Anadi has an undirected graph without self-loops and multiple edges. He wants to choose some dominoes and place them on the edges of this graph. He can use at most one domino of each type. Each edge can fit at most one domino. It's not necessary to place a domino on each edge of the graph.When placing a domino on an edge, he also chooses its direction. In other words, one half of any placed domino must be directed toward one of the endpoints of the edge and the other half must be directed toward the other endpoint. There's a catch: if there are multiple halves of dominoes directed toward the same vertex, each of these halves must contain the same number of dots.How many dominoes at most can Anadi place on the edges of his graph?",
        "lang": "Mono C#",
        "fix_exec_outcome": "",
        "insert_cnt": 1,
        "fix_source_code": "",
        "prob_desc_notes": "NoteHere is an illustration of Anadi's graph from the first sample test:  And here is one of the ways to place a domino on each of its edges:  Note that each vertex is faced by the halves of dominoes with the same number of dots. For instance, all halves directed toward vertex $$$1$$$ have three dots.",
        "file_name": "C#.jsonl",
        "tags": [
            "graphs",
            "brute force"
        ],
        "prob_desc_output_to": "standard output",
        "prob_desc_created_at": "1569143100",
        "prob_desc_memory_limit": "256 megabytes",
        "prob_desc_sample_outputs": [
            "4",
            "0",
            "1",
            "16"
        ],
        "hidden_unit_tests": "[{\"input\": \"4 4\\r\\n1 2\\r\\n2 3\\r\\n3 4\\r\\n4 1\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"7 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"3 1\\r\\n1 3\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"7 21\\r\\n1 2\\r\\n1 3\\r\\n1 4\\r\\n1 5\\r\\n1 6\\r\\n1 7\\r\\n2 3\\r\\n2 4\\r\\n2 5\\r\\n2 6\\r\\n2 7\\r\\n3 4\\r\\n3 5\\r\\n3 6\\r\\n3 7\\r\\n4 5\\r\\n4 6\\r\\n4 7\\r\\n5 6\\r\\n5 7\\r\\n6 7\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"4 4\\r\\n4 2\\r\\n2 3\\r\\n3 4\\r\\n2 1\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"5 7\\r\\n4 3\\r\\n3 2\\r\\n1 4\\r\\n5 3\\r\\n5 2\\r\\n4 5\\r\\n1 5\\r\\n\", \"output\": [\"7\"]}, {\"input\": \"6 9\\r\\n2 5\\r\\n3 6\\r\\n1 2\\r\\n1 4\\r\\n2 6\\r\\n6 1\\r\\n3 4\\r\\n1 3\\r\\n5 3\\r\\n\", \"output\": [\"9\"]}, {\"input\": \"7 5\\r\\n5 6\\r\\n3 7\\r\\n7 2\\r\\n4 2\\r\\n1 4\\r\\n\", \"output\": [\"5\"]}, {\"input\": \"7 14\\r\\n7 3\\r\\n2 4\\r\\n2 1\\r\\n2 5\\r\\n5 3\\r\\n6 7\\r\\n4 7\\r\\n5 4\\r\\n7 5\\r\\n4 3\\r\\n4 1\\r\\n6 1\\r\\n6 3\\r\\n3 1\\r\\n\", \"output\": [\"13\"]}, {\"input\": \"7 15\\r\\n4 6\\r\\n7 3\\r\\n3 1\\r\\n6 5\\r\\n2 7\\r\\n3 6\\r\\n7 6\\r\\n2 6\\r\\n7 5\\r\\n3 5\\r\\n5 4\\r\\n4 7\\r\\n2 1\\r\\n2 4\\r\\n2 3\\r\\n\", \"output\": [\"14\"]}, {\"input\": \"7 18\\r\\n1 5\\r\\n5 7\\r\\n1 3\\r\\n1 6\\r\\n4 5\\r\\n3 7\\r\\n6 7\\r\\n4 7\\r\\n2 7\\r\\n1 2\\r\\n7 1\\r\\n5 6\\r\\n6 2\\r\\n4 2\\r\\n5 3\\r\\n3 6\\r\\n4 6\\r\\n4 3\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"7 14\\r\\n2 7\\r\\n5 7\\r\\n3 4\\r\\n4 2\\r\\n2 3\\r\\n4 1\\r\\n6 5\\r\\n4 7\\r\\n6 2\\r\\n6 1\\r\\n5 3\\r\\n5 1\\r\\n7 6\\r\\n3 1\\r\\n\", \"output\": [\"13\"]}, {\"input\": \"7 11\\r\\n4 7\\r\\n6 4\\r\\n5 1\\r\\n1 4\\r\\n5 4\\r\\n1 2\\r\\n3 4\\r\\n4 2\\r\\n6 1\\r\\n3 1\\r\\n7 1\\r\\n\", \"output\": [\"10\"]}, {\"input\": \"7 18\\r\\n3 2\\r\\n5 3\\r\\n6 7\\r\\n7 3\\r\\n5 4\\r\\n4 6\\r\\n2 4\\r\\n7 1\\r\\n5 6\\r\\n5 2\\r\\n5 1\\r\\n3 4\\r\\n7 4\\r\\n6 1\\r\\n3 6\\r\\n7 2\\r\\n1 3\\r\\n1 2\\r\\n\", \"output\": [\"15\"]}, {\"input\": \"7 17\\r\\n1 7\\r\\n5 6\\r\\n6 3\\r\\n1 2\\r\\n1 6\\r\\n3 4\\r\\n6 7\\r\\n4 5\\r\\n1 3\\r\\n1 5\\r\\n4 1\\r\\n5 2\\r\\n3 5\\r\\n4 6\\r\\n7 5\\r\\n7 2\\r\\n6 2\\r\\n\", \"output\": [\"14\"]}, {\"input\": \"7 10\\r\\n3 6\\r\\n6 1\\r\\n4 6\\r\\n1 7\\r\\n7 4\\r\\n5 3\\r\\n5 6\\r\\n6 7\\r\\n7 5\\r\\n5 1\\r\\n\", \"output\": [\"10\"]}, {\"input\": \"1 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 1\\r\\n2 1\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"3 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"3 2\\r\\n2 3\\r\\n1 3\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"3 3\\r\\n1 2\\r\\n2 3\\r\\n1 3\\r\\n\", \"output\": [\"3\"]}, {\"input\": \"4 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"4 2\\r\\n2 4\\r\\n1 3\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"4 6\\r\\n2 1\\r\\n1 4\\r\\n2 4\\r\\n3 1\\r\\n3 2\\r\\n3 4\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"5 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"5 3\\r\\n5 1\\r\\n1 4\\r\\n5 4\\r\\n\", \"output\": [\"3\"]}, {\"input\": \"5 10\\r\\n1 2\\r\\n3 4\\r\\n1 3\\r\\n2 3\\r\\n5 4\\r\\n5 1\\r\\n4 1\\r\\n5 3\\r\\n5 2\\r\\n2 4\\r\\n\", \"output\": [\"10\"]}, {\"input\": \"6 0\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"6 3\\r\\n4 2\\r\\n5 4\\r\\n4 3\\r\\n\", \"output\": [\"3\"]}, {\"input\": \"6 6\\r\\n4 3\\r\\n4 6\\r\\n1 2\\r\\n4 5\\r\\n6 3\\r\\n3 2\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"6 15\\r\\n4 3\\r\\n2 1\\r\\n3 6\\r\\n1 3\\r\\n4 1\\r\\n2 3\\r\\n3 5\\r\\n4 5\\r\\n6 1\\r\\n2 5\\r\\n1 5\\r\\n2 6\\r\\n6 4\\r\\n5 6\\r\\n4 2\\r\\n\", \"output\": [\"15\"]}, {\"input\": \"6 12\\r\\n2 1\\r\\n4 3\\r\\n1 5\\r\\n6 4\\r\\n6 2\\r\\n3 6\\r\\n1 6\\r\\n2 4\\r\\n1 4\\r\\n2 5\\r\\n5 4\\r\\n1 3\\r\\n\", \"output\": [\"12\"]}, {\"input\": \"7 1\\r\\n5 3\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"7 2\\r\\n5 1\\r\\n3 5\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"7 3\\r\\n1 5\\r\\n5 7\\r\\n2 7\\r\\n\", \"output\": [\"3\"]}, {\"input\": \"7 4\\r\\n3 7\\r\\n7 5\\r\\n1 3\\r\\n1 6\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"7 6\\r\\n3 5\\r\\n7 1\\r\\n3 7\\r\\n5 4\\r\\n7 4\\r\\n3 6\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"7 7\\r\\n2 5\\r\\n6 1\\r\\n5 4\\r\\n7 2\\r\\n3 2\\r\\n4 1\\r\\n7 3\\r\\n\", \"output\": [\"7\"]}, {\"input\": \"7 8\\r\\n4 1\\r\\n5 7\\r\\n6 4\\r\\n7 1\\r\\n6 3\\r\\n3 4\\r\\n3 1\\r\\n6 7\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"7 9\\r\\n2 6\\r\\n7 4\\r\\n2 5\\r\\n2 7\\r\\n4 2\\r\\n3 5\\r\\n5 6\\r\\n6 7\\r\\n7 3\\r\\n\", \"output\": [\"9\"]}, {\"input\": \"7 11\\r\\n2 4\\r\\n1 3\\r\\n5 2\\r\\n2 7\\r\\n1 4\\r\\n4 3\\r\\n2 1\\r\\n7 6\\r\\n3 2\\r\\n7 4\\r\\n4 5\\r\\n\", \"output\": [\"11\"]}, {\"input\": \"7 12\\r\\n6 3\\r\\n3 5\\r\\n7 5\\r\\n1 5\\r\\n1 7\\r\\n7 6\\r\\n4 1\\r\\n2 1\\r\\n1 6\\r\\n5 6\\r\\n3 4\\r\\n4 2\\r\\n\", \"output\": [\"12\"]}, {\"input\": \"7 13\\r\\n6 5\\r\\n5 7\\r\\n4 2\\r\\n7 2\\r\\n4 1\\r\\n6 7\\r\\n4 3\\r\\n1 6\\r\\n2 5\\r\\n5 4\\r\\n2 1\\r\\n6 4\\r\\n6 2\\r\\n\", \"output\": [\"13\"]}, {\"input\": \"7 16\\r\\n3 5\\r\\n1 3\\r\\n3 7\\r\\n4 2\\r\\n1 4\\r\\n1 6\\r\\n7 6\\r\\n5 1\\r\\n7 2\\r\\n4 3\\r\\n3 6\\r\\n2 3\\r\\n2 5\\r\\n4 5\\r\\n2 6\\r\\n5 7\\r\\n\", \"output\": [\"15\"]}, {\"input\": \"7 17\\r\\n4 6\\r\\n1 7\\r\\n7 5\\r\\n3 7\\r\\n7 2\\r\\n2 5\\r\\n6 7\\r\\n1 3\\r\\n5 1\\r\\n6 2\\r\\n4 2\\r\\n3 2\\r\\n1 2\\r\\n5 3\\r\\n4 5\\r\\n3 4\\r\\n1 6\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"7 19\\r\\n6 1\\r\\n6 4\\r\\n6 5\\r\\n1 7\\r\\n2 7\\r\\n3 5\\r\\n7 6\\r\\n2 4\\r\\n5 7\\r\\n3 4\\r\\n6 2\\r\\n4 1\\r\\n5 1\\r\\n4 7\\r\\n3 2\\r\\n4 5\\r\\n3 1\\r\\n2 5\\r\\n6 3\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"7 20\\r\\n4 7\\r\\n1 4\\r\\n2 3\\r\\n4 3\\r\\n3 7\\r\\n7 5\\r\\n4 5\\r\\n1 2\\r\\n6 7\\r\\n3 1\\r\\n3 5\\r\\n1 5\\r\\n1 7\\r\\n2 6\\r\\n6 4\\r\\n5 2\\r\\n5 6\\r\\n6 3\\r\\n1 6\\r\\n2 7\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"7 21\\r\\n3 5\\r\\n7 2\\r\\n2 3\\r\\n6 5\\r\\n5 2\\r\\n4 7\\r\\n2 6\\r\\n2 4\\r\\n6 7\\r\\n5 1\\r\\n1 4\\r\\n4 5\\r\\n5 7\\r\\n4 6\\r\\n3 1\\r\\n1 2\\r\\n3 4\\r\\n7 1\\r\\n3 7\\r\\n6 1\\r\\n3 6\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"7 12\\r\\n3 4\\r\\n5 4\\r\\n1 7\\r\\n7 3\\r\\n2 5\\r\\n3 2\\r\\n1 4\\r\\n5 6\\r\\n6 1\\r\\n6 3\\r\\n2 1\\r\\n5 7\\r\\n\", \"output\": [\"12\"]}, {\"input\": \"7 7\\r\\n7 6\\r\\n4 2\\r\\n3 1\\r\\n4 7\\r\\n6 3\\r\\n2 5\\r\\n1 5\\r\\n\", \"output\": [\"7\"]}, {\"input\": \"7 6\\r\\n7 5\\r\\n5 2\\r\\n1 5\\r\\n5 4\\r\\n3 5\\r\\n6 5\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"7 15\\r\\n5 1\\r\\n3 2\\r\\n2 5\\r\\n3 5\\r\\n6 1\\r\\n4 3\\r\\n6 2\\r\\n4 5\\r\\n7 5\\r\\n3 6\\r\\n3 1\\r\\n7 3\\r\\n4 6\\r\\n6 5\\r\\n6 7\\r\\n\", \"output\": [\"13\"]}, {\"input\": \"7 18\\r\\n3 7\\r\\n3 2\\r\\n2 1\\r\\n1 7\\r\\n5 1\\r\\n3 4\\r\\n5 6\\r\\n4 2\\r\\n6 2\\r\\n1 4\\r\\n2 5\\r\\n6 3\\r\\n3 1\\r\\n6 7\\r\\n6 1\\r\\n7 2\\r\\n6 4\\r\\n3 5\\r\\n\", \"output\": [\"15\"]}, {\"input\": \"7 19\\r\\n1 2\\r\\n7 3\\r\\n3 4\\r\\n4 7\\r\\n3 6\\r\\n7 5\\r\\n6 2\\r\\n4 6\\r\\n6 7\\r\\n5 2\\r\\n3 2\\r\\n6 5\\r\\n4 1\\r\\n2 4\\r\\n4 5\\r\\n6 1\\r\\n3 1\\r\\n1 7\\r\\n5 1\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"7 16\\r\\n3 2\\r\\n6 3\\r\\n6 1\\r\\n5 6\\r\\n7 5\\r\\n5 2\\r\\n6 2\\r\\n2 1\\r\\n5 4\\r\\n4 1\\r\\n7 2\\r\\n1 5\\r\\n2 4\\r\\n7 3\\r\\n1 7\\r\\n6 7\\r\\n\", \"output\": [\"15\"]}, {\"input\": \"7 12\\r\\n4 1\\r\\n6 4\\r\\n3 4\\r\\n3 1\\r\\n2 4\\r\\n7 5\\r\\n5 4\\r\\n2 1\\r\\n6 7\\r\\n2 3\\r\\n7 4\\r\\n6 5\\r\\n\", \"output\": [\"11\"]}]"
    }
}