{
    "oai_response": null,
    "source_data": {
        "delete_cnt": 0,
        "fix_code_uid": "",
        "difficulty": 1600,
        "replace_cnt": 4,
        "fix_ops_cnt": 4,
        "prob_desc_output_spec": "In the only line print the only integer\u00a0\u2014 the answer for the problem.",
        "apr_id": "b4f364d7e12796ecff3b5e3aade9d258",
        "bug_source_code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing static Template;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing Pi = Pair<int, int>;\n\nclass Solver\n{\n    Scanner sc = new Scanner();\n    //\n    public void Solve()\n    {\n        int l, r, x, y;\n        sc.Make(out l, out r, out x, out y);\n        var fx = Factorize(x);\n        var fy = Factorize(y);\n        foreach (var p in fx)\n        {\n            if (!fy.ContainsKey(p.Key)||fy[p.Key]<p.Value)\n                Fail(0);\n        }\n        var n = new List<P>();\n        foreach (var p in fy)\n        {\n            if (!fx.ContainsKey(p.Key)) fx[p.Key] = 0;\n            n.Add(new P(p.Key, p.Value, fx[p.Key]));\n        }\n        var res = 0;\n        var ok = new Dictionary<long, Dictionary<long, bool>>();\n        for(var i = 0; i < (1 << n.Count); i++)\n        {\n            long u = 1, v = 1;\n            for(var j=0;j<n.Count;j++)\n                if ((1 & i >> j) == 1)\n                {\n                    for (var k = 0; k < n[j].x; k++)\n                        u *= n[k].v;\n                    for (var k = 0; k < n[j].y; k++)\n                        v *= n[k].v;\n                }\n                else\n                {\n                    for (var k = 0; k < n[j].x; k++)\n                        v *= n[k].v;\n                    for (var k = 0; k < n[j].y; k++)\n                        u *= n[k].v;\n                }\n            if (r < u || u < l || r < v || v < l) continue;\n            if (!ok.ContainsKey(u))\n                ok[u] = new Dictionary<long, bool>();\n            if (!ok[u].ContainsKey(v))\n            {\n                res++;\n                ok[u][v] = true;\n            }\n        }\n        WriteLine(res);\n    }\n    struct P\n    {\n        public long v, x, y;\n        public P(long V,int X,int Y)\n        {\n            v = V;x = X;y = Y;\n        }\n    }\n\n    public static Dictionary<long, int> Factorize(long num)\n    {\n        var dic = new Dictionary<long, int>();\n        for (var i = 2L; i * i <= num; i++)\n        {\n            var ct = 0;\n            while (num % i == 0)\n            {\n                ct++;\n                num /= i;\n            }\n            if (ct != 0) dic[i] = ct;\n        }\n        if (num != 1) dic[num] = 1;\n        return dic;\n    }\n}\n\n#region Template\npublic class Template\n{\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver().Solve();\n        Console.Out.Flush();\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T>\n    { if (a.CompareTo(b) == 1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T>\n    { if (a.CompareTo(b) == -1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b)\n    { var t = b; b = a; a = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f)\n    {\n        var rt = new T[n];\n        for (var i = 0; i < rt.Length; ++i)\n            rt[i] = f();\n        return rt;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<int, T> f)\n    {\n        var rt = new T[n];\n        for (var i = 0; i < rt.Length; ++i)\n            rt[i] = f(i);\n        return rt;\n    }\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\n\npublic class Scanner\n{\n    public string Str => ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    public Pair<T1, T2> PairMake<T1, T2>() => new Pair<T1, T2>(Next<T1>(), Next<T2>());\n    public Pair<T1, T2, T3> PairMake<T1, T2, T3>() => new Pair<T1, T2, T3>(Next<T1>(), Next<T2>(), Next<T3>());\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString() => $\"{v1.ToString()} {v2.ToString()}\";\n    public void Tie(out T1 a, out T2 b) { a = v1; b = v2; }\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString() => $\"{base.ToString()} {v3.ToString()}\";\n    public void Tie(out T1 a, out T2 b, out T3 c) { Tie(out a, out b); c = v3; }\n}\n#endregion\n",
        "prob_desc_input_spec": "The only line contains four integers l,\u2009r,\u2009x,\u2009y (1\u2009\u2264\u2009l\u2009\u2264\u2009r\u2009\u2264\u2009109, 1\u2009\u2264\u2009x\u2009\u2264\u2009y\u2009\u2264\u2009109).",
        "src_uid": "d37dde5841116352c9b37538631d0b15",
        "bug_code_uid": "7bf34d6849a2411d275261c3416399ee",
        "equal_cnt": 5,
        "prob_desc_time_limit": "1 second",
        "similarity_score": 0.9994094967842102,
        "bug_exec_outcome": "RUNTIME_ERROR",
        "lang_cluster": "C#",
        "potential_dominant_fix_op": "replace",
        "prob_desc_sample_inputs": [
            "1 2 1 2",
            "1 12 1 12",
            "50 100 3 30"
        ],
        "prob_desc_input_from": "standard input",
        "prob_desc_description": "Today on Informatics class Nastya learned about GCD and LCM (see links below). Nastya is very intelligent, so she solved all the tasks momentarily and now suggests you to solve one of them as well.We define a pair of integers (a,\u2009b) good, if GCD(a,\u2009b)\u2009=\u2009x and LCM(a,\u2009b)\u2009=\u2009y, where GCD(a,\u2009b) denotes the greatest common divisor of a and b, and LCM(a,\u2009b) denotes the least common multiple of a and b.You are given two integers x and y. You are to find the number of good pairs of integers (a,\u2009b) such that l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r. Note that pairs (a,\u2009b) and (b,\u2009a) are considered different if a\u2009\u2260\u2009b.",
        "lang": "Mono C#",
        "fix_exec_outcome": "",
        "insert_cnt": 0,
        "fix_source_code": "",
        "prob_desc_notes": "NoteIn the first example there are two suitable good pairs of integers (a,\u2009b): (1,\u20092) and (2,\u20091).In the second example there are four suitable good pairs of integers (a,\u2009b): (1,\u200912), (12,\u20091), (3,\u20094) and (4,\u20093).In the third example there are good pairs of integers, for example, (3,\u200930), but none of them fits the condition l\u2009\u2264\u2009a,\u2009b\u2009\u2264\u2009r.",
        "file_name": "C#.jsonl",
        "tags": [
            "math",
            "number theory"
        ],
        "prob_desc_output_to": "standard output",
        "prob_desc_created_at": "1529339700",
        "prob_desc_memory_limit": "256 megabytes",
        "prob_desc_sample_outputs": [
            "2",
            "4",
            "0"
        ],
        "hidden_unit_tests": "[{\"input\": \"1 2 1 2\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 12 1 12\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"50 100 3 30\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000000000 1 1000000000\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"1 1000000000 158260522 200224287\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000000000 2 755829150\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"1 1000000000 158260522 158260522\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"1 1000000000 877914575 877914575\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"232 380232688 116 760465376\\r\\n\", \"output\": [\"30\"]}, {\"input\": \"47259 3393570 267 600661890\\r\\n\", \"output\": [\"30\"]}, {\"input\": \"1 1000000000 1 672672000\\r\\n\", \"output\": [\"64\"]}, {\"input\": \"1000000000 1000000000 1000000000 1000000000\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"1 1000000000 1 649209600\\r\\n\", \"output\": [\"32\"]}, {\"input\": \"1 1000000000 1 682290000\\r\\n\", \"output\": [\"32\"]}, {\"input\": \"1 1000000000 1 228614400\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"1 1000000000 1 800280000\\r\\n\", \"output\": [\"32\"]}, {\"input\": \"1 1000000000 1 919987200\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"1 1000000000 1 456537870\\r\\n\", \"output\": [\"64\"]}, {\"input\": \"1 1000000000 1 7198102\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"1 1000000000 1 58986263\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"1 1000000000 1 316465536\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"1 1000000000 1 9558312\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"1 1000000000 1 5461344\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"58 308939059 29 617878118\\r\\n\", \"output\": [\"62\"]}, {\"input\": \"837 16262937 27 504151047\\r\\n\", \"output\": [\"28\"]}, {\"input\": \"47275 402550 25 761222050\\r\\n\", \"output\": [\"12\"]}, {\"input\": \"22 944623394 22 944623394\\r\\n\", \"output\": [\"32\"]}, {\"input\": \"1032 8756124 12 753026664\\r\\n\", \"output\": [\"18\"]}, {\"input\": \"7238 939389 11 618117962\\r\\n\", \"output\": [\"10\"]}, {\"input\": \"58351 322621 23 818489477\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"3450 7068875 25 975504750\\r\\n\", \"output\": [\"86\"]}, {\"input\": \"13266 1606792 22 968895576\\r\\n\", \"output\": [\"14\"]}, {\"input\": \"21930 632925 15 925336350\\r\\n\", \"output\": [\"42\"]}, {\"input\": \"2193 4224517 17 544962693\\r\\n\", \"output\": [\"42\"]}, {\"input\": \"526792 39807152 22904 915564496\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"67728 122875524 16932 491502096\\r\\n\", \"output\": [\"12\"]}, {\"input\": \"319813 63298373 24601 822878849\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"572464 23409136 15472 866138032\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"39443 809059020 19716 777638472\\r\\n\", \"output\": [\"12\"]}, {\"input\": \"2544768 8906688 27072 837228672\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"413592 46975344 21768 892531536\\r\\n\", \"output\": [\"10\"]}, {\"input\": \"11349 816231429 11349 816231429\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"16578 939956022 16578 939956022\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"2783175 6882425 21575 887832825\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"2862252 7077972 22188 913058388\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1856828 13124976 25436 958123248\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"100 1000000000 158260522 158260522\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"100 1000000000 877914575 877914575\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"100 1000000000 602436426 602436426\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"100 1000000000 24979445 24979445\\r\\n\", \"output\": [\"1\"]}, {\"input\": \"1 1000000000 18470 112519240\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"1 1000000000 22692 2201124\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 1000000000 24190 400949250\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"1 1000000000 33409 694005157\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 1000000000 24967 470827686\\r\\n\", \"output\": [\"16\"]}, {\"input\": \"1 1000000000 35461 152517761\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"2 1000000000 158260522 200224287\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 1000000000 602436426 611751520\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 1000000000 861648772 942726551\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 1000000000 433933447 485982495\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 1000000000 262703497 480832794\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2672374 422235092 1336187 844470184\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1321815 935845020 1321815 935845020\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"29259607 69772909 2250739 907047817\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"11678540 172842392 2335708 864211960\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"297 173688298 2876112 851329152\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"7249 55497026 659 610467286\\r\\n\", \"output\": [\"28\"]}, {\"input\": \"398520 1481490 810 728893080\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"2354 369467362 1177 738934724\\r\\n\", \"output\": [\"14\"]}, {\"input\": \"407264 2497352 1144 889057312\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"321399 1651014 603 879990462\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"475640 486640 440 526057840\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"631714 179724831 1136 717625968\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"280476 1595832 588 761211864\\r\\n\", \"output\": [\"8\"]}, {\"input\": \"10455 39598005 615 673166085\\r\\n\", \"output\": [\"6\"]}, {\"input\": \"24725 19759875 575 849674625\\r\\n\", \"output\": [\"22\"]}, {\"input\": \"22 158 2 1738\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 2623 1 2623\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"7 163677675 3 18\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"159 20749927 1 158\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"5252 477594071 1 5251\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2202 449433679 3 6603\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"6 111 3 222\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"26 46 2 598\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"26 82 2 1066\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 2993 1 2993\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"17 17 1 289\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"177 267 3 15753\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"7388 22705183 1 7387\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 100 3 100\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000 6 1024\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 100 2 4\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 10000 2 455\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000000000 250000000 1000000000\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"3 3 1 1\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000000000 100000000 1000000000\\r\\n\", \"output\": [\"4\"]}, {\"input\": \"5 10 3 3\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000 5 13\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"2 2 3 3\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000000000 499999993 999999986\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 1 1 10\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 10 10 100\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"1 1000 4 36\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 1000000000 10000000 20000000\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"100 100 5 5\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"3 3 3 9\\r\\n\", \"output\": [\"0\"]}, {\"input\": \"36 200 24 144\\r\\n\", \"output\": [\"2\"]}, {\"input\": \"1 100 3 10\\r\\n\", \"output\": [\"0\"]}]"
    }
}